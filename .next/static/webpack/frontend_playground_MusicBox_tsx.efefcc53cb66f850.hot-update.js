"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("frontend_playground_MusicBox_tsx",{

/***/ "./frontend/playground/Sound.ts":
/*!**************************************!*\
  !*** ./frontend/playground/Sound.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"playEffectts\": function() { return /* binding */ playEffectts; },\n/* harmony export */   \"playInstruments\": function() { return /* binding */ playInstruments; },\n/* harmony export */   \"playSampler\": function() { return /* binding */ playSampler; },\n/* harmony export */   \"playSamples\": function() { return /* binding */ playSamples; },\n/* harmony export */   \"playScheduling\": function() { return /* binding */ playScheduling; },\n/* harmony export */   \"playSignal\": function() { return /* binding */ playSignal; },\n/* harmony export */   \"playSimple\": function() { return /* binding */ playSimple; },\n/* harmony export */   \"playSquence\": function() { return /* binding */ playSquence; },\n/* harmony export */   \"playTimeControl\": function() { return /* binding */ playTimeControl; }\n/* harmony export */ });\n/* harmony import */ var tone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tone */ \"./node_modules/tone/build/esm/index.js\");\n/* harmony import */ var _Visuals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Visuals */ \"./frontend/playground/Visuals.ts\");\n/* harmony import */ var _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data/CGMdata1 */ \"./frontend/playground/data/CGMdata1.ts\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);\n\n\n //here is where I can load different data sets\n\n//BG array - this works, but there might be a more elegant way, and I need to decide whether to actually remove the null values or not\n//from Luciano: const glucoseValues = data.filter((value) => value.glucose !== null)\nlet glucoseValues = _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__.data.filter((value)=>value.glucose > 0).map((value)=>value.glucose);\nglucoseValues = glucoseValues.filter(Number);\n// glucoseValues.forEach((item, index) => {\n//   console.log(item, index);\n// });\n// console.log(glucoseValues.reduce((previousValue, currentValue)=>previousValue + currentValue, 0));\nlet midGlucose = glucoseValues.at(Math.floor(glucoseValues.length / 2));\nvar _glucoseValues_reduce;\n//@ts-ignore\n// let avgGlucose = ((glucoseValues.reduce((previousValue, currentValue) => previousValue + currentValue, 0))/glucoseValues.length);\nlet avgGlucose = ((_glucoseValues_reduce = glucoseValues.reduce((previousValue, currentValue)=>(previousValue !== null && previousValue !== void 0 ? previousValue : 0) + (currentValue !== null && currentValue !== void 0 ? currentValue : 0), 0)) !== null && _glucoseValues_reduce !== void 0 ? _glucoseValues_reduce : 1) / glucoseValues.length;\n//@ts-ignore\nlet calcMode = (Math.round(midGlucose % 1 * 10) + Math.floor(midGlucose)) % 7;\nlet calcKey = (Math.round(avgGlucose % 1 * 10) + Math.floor(avgGlucose)) % 12;\nlet bpmIndex = 0;\nlet bpmRange = [\n    120,\n    220\n];\n//@ts-ignore\nlet calcBPM = convertRange((Math.round(glucoseValues.at(bpmIndex) % 1 * 10) + Math.floor(glucoseValues.at(bpmIndex))) % 20, [\n    0,\n    20\n], bpmRange);\nconsole.log(\"Mode # = \" + calcMode);\nconsole.log(\"Key # = \" + calcKey);\nconsole.log(\"BPM = \" + calcBPM);\n//create a reordered array for CGM data playback, intersperses groups of 3\nlet interBGArray = [];\nlet interJump = Math.floor(glucoseValues.length / 3);\nlet partArray1 = glucoseValues.slice(0, interJump);\nlet partArray2 = glucoseValues.slice(interJump, interJump * 2);\nlet partArray3 = glucoseValues.slice(interJump * 2);\nfor(let i = 0; i < interJump; i++){\n    interBGArray.push(partArray1[i], partArray2[i], partArray3[i]);\n}\nconsole.log(\"INTER =\", interBGArray);\nconsole.log(\"BG = \", glucoseValues);\n//////////////////////////////////\n// create new arrays with values to feed into visuals and sounds through scaling/linear interpolation\n//from: https://stackoverflow.com/questions/14224535/scaling-between-two-number-ranges\nfunction convertRange(value, r1, r2) {\n    return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\nconst maxBG = Math.max(...glucoseValues);\nconst minBG = Math.min(...glucoseValues);\n//arrays for use with visuals and audio (not dedicated, use as appropriate)\nconst bgRange01 = glucoseValues.map((num)=>convertRange(num, [\n        minBG,\n        maxBG\n    ], [\n        0,\n        1\n    ]));\nconst bgRange9 = glucoseValues.map((num)=>convertRange(num, [\n        minBG,\n        maxBG\n    ], [\n        0,\n        9\n    ]));\nconst bgRange310 = glucoseValues.map((num)=>convertRange(num, [\n        minBG,\n        maxBG\n    ], [\n        0.0001,\n        0.01\n    ]));\nconst bgRange100 = glucoseValues.map((num)=>convertRange(num, [\n        minBG,\n        maxBG\n    ], [\n        0.01,\n        0.1\n    ]));\nconst bgRange300 = glucoseValues.map((num)=>convertRange(num, [\n        minBG,\n        maxBG\n    ], [\n        0.0001,\n        0.1\n    ]));\n//SCALE_MAKING (with help from https://www.guitarland.com/MusicTheoryWithToneJS/PlayModes.html)\nconst majorFormula = [\n    0,\n    2,\n    4,\n    5,\n    7,\n    9,\n    11\n];\nconst modeNames = [\n    \"major\",\n    \"dorian\",\n    \"phrygian\",\n    \"lydian\",\n    \"mixolydian\",\n    \"aeolian\",\n    \"locrian\"\n];\nconst myModeNum = calcMode;\nconst myKey = calcKey;\nconst myModeFormula = makeModeFormula(majorFormula, myModeNum, myKey, 11);\n//parentScaleFormula is interval spacings to be repeated (ex. majorFormula), modeNum picks which interval to use as root (hence selects mode), root is pitch class (i.e key) base MIDI note from 0-11, formulaLength allows for creating longer and shorter repetitions of the interval spacings\nfunction makeModeFormula(parentScaleFormula, modeNum) {\n    let root = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, formulaLength = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 9;\n    let scaleIndex = 0;\n    let modeFormula = [];\n    let modeInterval;\n    for(let i = 0; i < parentScaleFormula.length * formulaLength; i++){\n        scaleIndex = (i + modeNum) % parentScaleFormula.length;\n        modeInterval = (parentScaleFormula[scaleIndex] - parentScaleFormula[modeNum] + 12) % 12;\n        modeInterval = modeInterval + root + Math.floor(i / parentScaleFormula.length) * 12;\n        modeFormula.push(modeInterval);\n    }\n    console.log(\"mode=\" + modeNames[modeNum] + \" formula=\" + modeFormula.toString());\n    return modeFormula;\n}\n//modeFormula = the result of the modeMakeFormula\n//upperLimit = how many scaleDegrees and hence intervals to spread the notes out over, my recommended approach is to take the length of the majorFormula (or whatever base interval formula being used) and multiply by the desired number of octaves to spread out over.\n//baseOctave = what octave to start at\nfunction convertBGtoNotes(modeFormula, upperLimit) {\n    let baseOctave = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    let bgScaleDegs;\n    let bgIntervals;\n    bgScaleDegs = glucoseValues.map((num)=>Math.round(convertRange(num, [\n            minBG,\n            maxBG\n        ], [\n            0,\n            upperLimit - 1\n        ])));\n    bgIntervals = bgScaleDegs.map((num)=>modeFormula[num] + baseOctave * 12);\n    return bgIntervals;\n}\n//create a synth and connect it to the main output (your speakers)\nconst reverbA = new tone__WEBPACK_IMPORTED_MODULE_0__.Reverb(5);\nconst panVolS1 = new tone__WEBPACK_IMPORTED_MODULE_0__.PanVol(-0.7, 0).toDestination();\nconst panVolS2 = new tone__WEBPACK_IMPORTED_MODULE_0__.PanVol(0.7, 0).toDestination();\nconst panVolS3 = new tone__WEBPACK_IMPORTED_MODULE_0__.PanVol(0, 0).toDestination();\nconst panVolK1 = new tone__WEBPACK_IMPORTED_MODULE_0__.PanVol(0, -6).toDestination();\nconst kickSynth = new tone__WEBPACK_IMPORTED_MODULE_0__.MembraneSynth();\nconst synth = new tone__WEBPACK_IMPORTED_MODULE_0__.PluckSynth();\nconst synth2 = new tone__WEBPACK_IMPORTED_MODULE_0__.PluckSynth();\nconst synth3 = new tone__WEBPACK_IMPORTED_MODULE_0__.PluckSynth();\nconst fmSynth = new tone__WEBPACK_IMPORTED_MODULE_0__.FMSynth();\nconst fmSynth2 = new tone__WEBPACK_IMPORTED_MODULE_0__.FMSynth();\nconst fmSynth3 = new tone__WEBPACK_IMPORTED_MODULE_0__.FMSynth();\nconst fmMIOffset = 50;\nconst fmSwell = new tone__WEBPACK_IMPORTED_MODULE_0__.FMSynth();\nfmSwell.set({\n    harmonicity: 0.5,\n    modulationIndex: 5,\n    envelope: {\n        attack: 0.01\n    },\n    modulationEnvelope: {\n        attack: 0.1,\n        decay: 1.5,\n        sustain: 0.1\n    },\n    modulation: {\n        type: \"triangle8\"\n    },\n    oscillator: {\n        type: \"triangle13\"\n    }\n});\nsynth.connect(panVolS1);\nsynth.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nsynth2.connect(panVolS2);\nsynth2.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nsynth3.connect(panVolS3);\nsynth3.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nfmSynth.connect(panVolS1);\nfmSynth.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nfmSynth2.connect(panVolS2);\nfmSynth2.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nfmSynth3.connect(panVolS3);\nfmSynth3.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nfmSwell.connect(panVolS1);\nfmSwell.chain(reverbA, tone__WEBPACK_IMPORTED_MODULE_0__.Destination);\nkickSynth.connect(panVolK1);\n// * simple\nconst playSimple = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    //debugging:\n    console.log(glucoseValues.map((x)=>x * 10));\n    //console.log(Tone);\n    //play a middle 'C' for the duration of an 8th note\n    _Visuals__WEBPACK_IMPORTED_MODULE_1__.start();\n    //Visuals.fx4(function(){return Math.random()*10});\n    // Visuals.fx3(20, 0.5)\n    _Visuals__WEBPACK_IMPORTED_MODULE_1__.fx5(glucoseValues.map((x)=>x * 10), glucoseValues, 0.6, 0.5);\n    synth.triggerAttackRelease(\"C3\", \"8n\");\n    //this works\n    for(let i = 0; i < _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__.data.length; i++){\n        let bg = _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__.data[i].glucose;\n        if (bg >= 8.0) {\n            console.log(\"high \", i, _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__.data[i].glucose);\n        //do something here\n        } else if (bg <= 7.9 && bg >= 4.0) {\n            console.log(\"target \", i, _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__.data[i].glucose);\n        //do something here\n        } else if (bg < 4.0) {\n            console.log(\"low \", i, _data_CGMdata1__WEBPACK_IMPORTED_MODULE_2__.data[i].glucose);\n        //do something here\n        }\n    }\n};\n// * simple double\nconst playTimeControl = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    const now = tone__WEBPACK_IMPORTED_MODULE_0__.now();\n    // trigger the attack immediately\n    //!synth.triggerAttack('C4', now);\n    // wait one second before triggering the release\n    //! synth.triggerRelease(now + 3);\n    synth.triggerAttackRelease(\"G2\", \"1n\", now + 1, 1);\n};\n// * Sequence\nconst playSquence = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    //FFT analyzes the audio output, can use the numbers it returns to do stuff to the visuals\n    const fft = new tone__WEBPACK_IMPORTED_MODULE_0__.FFT(16);\n    fmSwell.connect(fft);\n    fft.set({\n        normalRange: true,\n        smoothing: 0.8\n    });\n    let counterS1Vel = 0;\n    let counterS2Vel = 0;\n    let counterS3Vel = 0;\n    const bgMIDI = convertBGtoNotes(myModeFormula, majorFormula.length * 3, 4);\n    const bgFreqs = bgMIDI.map((num)=>tone__WEBPACK_IMPORTED_MODULE_0__.mtof(num));\n    console.log(bgFreqs);\n    _Visuals__WEBPACK_IMPORTED_MODULE_1__.start();\n    //Visuals.fx5(glucoseValues.map(x=> x * 10), glucoseValues, 0.6, 0.5);\n    //Visuals.fx3(2, 0.6)\n    _Visuals__WEBPACK_IMPORTED_MODULE_1__.fx8(bgRange01, fftNorm);\n    //Visuals.fx8t();\n    //Visuals.fx8simple();\n    //Visuals.fx9ease();\n    //bgVisEvent(now);\n    //k is # of pulses, n is # of slots, c is notename as String (ex. \"C3\"); this is for creating rhythms from the data\n    function bjorklund(k, n, c) {\n        //returns k pulses (1s) followed by n-k rests (0s)\n        let seq = lodash__WEBPACK_IMPORTED_MODULE_3___default().times(k, lodash__WEBPACK_IMPORTED_MODULE_3___default().constant([\n            1\n        ])).concat(lodash__WEBPACK_IMPORTED_MODULE_3___default().times(n - k, lodash__WEBPACK_IMPORTED_MODULE_3___default().constant([\n            0\n        ])));\n        //console.log(_.times(k, _.constant([1])).concat(_.times(n - k, _.constant([0]))))\n        while(true){\n            //sets two variables to partition the values in the seq\n            let [head, remainder] = lodash__WEBPACK_IMPORTED_MODULE_3___default().partition(seq, (i)=>lodash__WEBPACK_IMPORTED_MODULE_3___default().isEqual(i, seq[0]));\n            //console.log(head, remainder, seq);\n            if (remainder.length < 2) break;\n            for(let i = 0; i < Math.min(head.length, remainder.length); i++){\n                seq[i] = seq[i].concat(seq.pop());\n            }\n        }\n        return lodash__WEBPACK_IMPORTED_MODULE_3___default().flatten(seq).map(function(value) {\n            if (value == 1) {\n                return c;\n            } else {\n                return null;\n            }\n        });\n    }\n    let notes = [];\n    let notes2 = [];\n    let notes3 = [];\n    let kick = [];\n    // create a new sequence with the synth and notes\n    const synthPart = new tone__WEBPACK_IMPORTED_MODULE_0__.Sequence(function(time, note) {\n        fmSynth.triggerAttackRelease(note, \"64n\", time, bgRange01[counterS1Vel % bgRange01.length]);\n        console.log(\"synthPart1\");\n        //this is a way of inserting other variable changes on a per note basis\n        //need to delete this if you want it to happen every bjorklund switch instead of note switch\n        /* fmSynth.set({\n      harmonicity: 1.5,\n      modulationIndex: 5,\n      envelope: {attack: 0.01},\n      modulationEnvelope: {attack: 0.1,\n      decay: 0.25,\n      sustain: 0.1},\n      modulation: {type: \"sine\"},\n      oscillator: {type: \"sine\"}\n      }) */ counterS1Vel++;\n    }, notes, \"8n\");\n    // create a new sequence with the synth and notes\n    const synthPart2 = new tone__WEBPACK_IMPORTED_MODULE_0__.Sequence(function(time, note) {\n        fmSynth2.triggerAttackRelease(note, \"64n\", time, bgRange01[counterS2Vel % bgRange01.length]);\n        console.log(\"synthPart2\");\n        counterS2Vel++;\n    }, notes2, \"8n\");\n    // create a new sequence with the synth and notes\n    const synthPart3 = new tone__WEBPACK_IMPORTED_MODULE_0__.Sequence(function(time, note) {\n        fmSynth3.triggerAttackRelease(note, \"64n\", time, bgRange01[counterS3Vel % bgRange01.length]);\n        console.log(\"synthPart3\");\n        counterS3Vel++;\n    }, notes3, \"8n\");\n    // create a new sequence with the synth and notes\n    const kickPart = new tone__WEBPACK_IMPORTED_MODULE_0__.Sequence(function(time, note) {\n        kickSynth.triggerAttackRelease(note, \"16n\", time);\n    }, kick, \"2n\");\n    // Setup the synth to be ready to play on beat 1\n    synthPart.start();\n    synthPart2.start();\n    synthPart3.start();\n    kickPart.start();\n    // Note that if you pass a time into the start method \n    // you can specify when the synth part starts \n    // e.g. .start('8n') will start after 1 eighth note// start the transport which controls the main timeline\n    //Set the BPM and start the transport\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.bpm.value = calcBPM;\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.start();\n    //function for punctual events that will happen on top of the Euclidean rhythms created by the Bjorklund function\n    function swellFMEvent1(s, freq, atk, dur) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            fmSwell.triggerAttackRelease(freq, dur);\n            fmSwell.set({\n                harmonicity: 0.5,\n                modulationIndex: 5,\n                envelope: {\n                    attack: atk\n                },\n                modulationEnvelope: {\n                    attack: atk,\n                    decay: 1.5,\n                    sustain: 0.1\n                },\n                modulation: {\n                    type: \"triangle8\"\n                },\n                oscillator: {\n                    type: \"triangle13\"\n                }\n            });\n        }, s);\n    }\n    function timbreShift(s, synthName, harmon, modindex) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            synthName.set({\n                harmonicity: harmon,\n                modulationIndex: modindex,\n                envelope: {\n                    attack: 0.001,\n                    decay: 0.005\n                },\n                modulationEnvelope: {\n                    attack: 0.001,\n                    decay: 0.05,\n                    sustain: 0\n                },\n                modulation: {\n                    type: \"sine\"\n                },\n                oscillator: {\n                    type: \"sine\"\n                }\n            });\n        }, s);\n    }\n    //function for scheduling changes in the Bjorklund rhythm of the specified synth part and any other change that would be synchornized with these changes\n    //s is for shedule - the time at which it happens; n is the BG number\n    function bgEvent(s, n, freq) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            synthPart.events = bjorklund(bgSplitMin(n), bgSplitMax(n), freq);\n            console.log(synthPart.events);\n            console.log(n);\n            tone__WEBPACK_IMPORTED_MODULE_0__.Draw.schedule(()=>{\n            // do drawing or DOM manipulation here\n            // Visuals.fx3(/*function(){let y =  fft.getValue(); return y[1]*1000 + 1}*/s, function(){let y =  fft.getValue(); return y[0]*10});\n            //Visuals.fx5(n, n, fftNorm, n*0.05)\t\n            //console.log(time);\n            }, time);\n        }, s);\n    }\n    //little function to get fft data values roughly between 0 and 1 - can change multiplier for different ranges etc.\n    //Q- how can your perform an operation (multiply) on the value returned from a function?\n    function fftNorm() {\n        let y = fft.getValue();\n        return y[0] * 10;\n    }\n    //function for scheduling changes in the Bjorklund rhythm of the specified synth part and any other change that would be synchornized with these changes\n    function bgEvent2(s, n, freq) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            synthPart2.events = bjorklund(bgSplitMin(n), bgSplitMax(n), freq);\n            console.log(synthPart2.events);\n            console.log(n);\n            tone__WEBPACK_IMPORTED_MODULE_0__.Draw.schedule(()=>{\n            // do drawing or DOM manipulation here\n            // Visuals.fx3(/*function(){let y =  fft.getValue(); return y[1]*1000 + 1}*/s, function(){let y =  fft.getValue(); return y[0]*10});\n            //\tVisuals.fx2(),\t\n            //console.log(time);\n            }, time);\n        }, s);\n    }\n    //function for scheduling changes in the Bjorklund rhythm of the specified synth part and any other change that would be synchornized with these changes\n    function bgEvent3(s, n, freq) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            synthPart3.events = bjorklund(bgSplitMin(n), bgSplitMax(n), freq);\n            console.log(synthPart3.events);\n            console.log(n);\n            tone__WEBPACK_IMPORTED_MODULE_0__.Draw.schedule(()=>{\n            // do drawing or DOM manipulation here\n            // Visuals.fx3(/*function(){let y =  fft.getValue(); return y[1]*1000 + 1}*/s, function(){let y =  fft.getValue(); return y[0]*10});\n            //\tVisuals.fx4(n),\t\n            //console.log(time);\n            }, time);\n        }, s);\n    }\n    //function for scheduling changes in the Bjorklund rhythm of the specified synth part and any other change that would be synchornized with these changes\n    function bgEvent4(s, n, freq) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            kickPart.events = bjorklund(bgSplitMin(n), bgSplitMax(n), freq);\n            console.log(kickPart.events);\n            console.log(n);\n            tone__WEBPACK_IMPORTED_MODULE_0__.Draw.schedule(()=>{\n            // do drawing or DOM manipulation here\n            // Visuals.fx3(/*function(){let y =  fft.getValue(); return y[1]*1000 + 1}*/s, function(){let y =  fft.getValue(); return y[0]*10});\n            //\tVisuals.fx4(n),\t\n            //console.log(time);\n            }, time);\n        }, s);\n    }\n    //helper functions for the bgEvent functions, Min splits the BG number at the decimal and returns the smaller of the two resulting integers, Max returns the larger\n    function bgSplitMin(n) {\n        return Math.min(Math.round(n % 1 * 10), Math.floor(n));\n    }\n    function bgSplitMax(n) {\n        return Math.max(Math.round(n % 1 * 10), Math.floor(n));\n    }\n    //function for scheduling changes in the visuals\n    //  s is when it will happen - when it is scheduled for.\n    function bgVisEvent(s) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            tone__WEBPACK_IMPORTED_MODULE_0__.Draw.schedule(()=>{\n                // do drawing or DOM manipulation here\n                _Visuals__WEBPACK_IMPORTED_MODULE_1__.fx8();\n                console.log(time);\n            }, time);\n        }, s);\n    }\n    //function for scheduling changes in the visuals\n    //  s is when it will happen - when it is scheduled for.\n    function bgVisEvent2(s, g, inv, sat, nn, ns, rot, lthrsh, ltol) {\n        tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n            tone__WEBPACK_IMPORTED_MODULE_0__.Draw.schedule(()=>{\n                // do drawing or DOM manipulation here\n                _Visuals__WEBPACK_IMPORTED_MODULE_1__.fx7(g, inv, sat, nn, ns, rot, lthrsh, ltol);\n                console.log(time);\n            }, time);\n        }, s);\n    }\n    // this works as a basic organizational logic - still need to work out coordination of sound and visual events which might not always change at the same time\n    //with the current BG events they keep going with their current data until they receive a change\n    //first variable of the BG event is when it is scheduled to happen, second is the BG value\n    //Overarching strucutre of the generative composition: 1) create as many Time counters as necessary; a new Time counter is necessary for any change that doesn't happen at the same time as an existing change (which will already have its own Time counter)\n    //2) Using a for loop, go through all the glucose values and create a score from that; this is where the timing of changes is determined, as well as what data is fed into the functions to determine what the changes are\n    let bgTime = 0;\n    let bgTimeB = 0; //if you don't want everything to start at once you can make an offset (ex. set bgTimeB to glucoseValues[1])\n    let bgTimeC = 0; //if you don't want everything to start at once you can make an offset (ex. set bgTimeC to glucoseValues[2])\n    let bgTime2 = 0;\n    //FIGURE OUT HOW TO LOOP\n    for(let i = 0; i < glucoseValues.length; i++){\n        let bg = glucoseValues[i];\n        //conditional statements to allow the possibility of different things happening depending on whether the BG reading is high, on target, or low (could add more conditions and/or change existing thresholds)\n        if (bg >= 8.0) {\n            console.log(\"high \", glucoseValues[i], bgTime, bgFreqs[i]);\n            //do something here\n            //swell event happens at the designated time and with the designated Frequecy value (multiplication by 0.5 would lower it by 1 octave)\n            swellFMEvent1(bgTime, bgFreqs[i] * 0.125, bgRange01[i], bgRange01[i] * 2);\n            //bgEvents are the Euclidean rhythms, here we determine when they change (ex. bgTime), what rhythm they change to (ex. glucoseValues[i]), and what frequency/note is played (ex. bg Freqs[i])\n            bgEvent(bgTime, glucoseValues[i], bgFreqs[i]);\n            timbreShift(bgTime, fmSynth, 1.5, fmMIOffset * bgRange01[i]);\n            bgEvent2(bgTimeB, glucoseValues[(i + 1) % glucoseValues.length], bgFreqs[(i + 1) % glucoseValues.length]);\n            timbreShift(bgTimeB, fmSynth2, 1.5, fmMIOffset * bgRange01[(i + 1) % glucoseValues.length]);\n            bgEvent3(bgTimeC, glucoseValues[(i + 2) % glucoseValues.length], bgFreqs[(i + 2) % glucoseValues.length]);\n            timbreShift(bgTimeC, fmSynth3, 1.5, fmMIOffset * bgRange01[(i + 2) % glucoseValues.length]);\n            bgEvent4(bgTime, glucoseValues[i], bgFreqs[i] * 0.125);\n        //scheduling of a change in the visuals, first variable determines when, the rest depend on the visual synth in question\n        //bgVisEvent2(bgTime2, bgRange01[i], bgRange01[i+1], bgRange9[i+2], bgRange9[i+7], bgRange01[i+3], bgRange310[i+4], bgRange100[i+5], bgRange300[i+6])\n        //bgVisEvent2(bgTime, bgRange01[i], bgRange01[i], bgRange9[i],bgRange9[i], bgRange01[i], bgRange310[i], bgRange100[i], bgRange300[i])\n        } else if (bg <= 7.9 && bg >= 4.0) {\n            console.log(\"target \", glucoseValues[i], bgTime, bgFreqs[i]);\n            //do something here\n            swellFMEvent1(bgTime, bgFreqs[i] * 0.125, bgRange01[i], bgRange01[i] * 5);\n            bgEvent(bgTime, glucoseValues[i], bgFreqs[i]);\n            timbreShift(bgTime, fmSynth, 1.5, fmMIOffset * bgRange01[i]);\n            bgEvent2(bgTimeB, glucoseValues[(i + 1) % glucoseValues.length], bgFreqs[(i + 1) % glucoseValues.length]);\n            timbreShift(bgTimeB, fmSynth2, 1.5, fmMIOffset * bgRange01[(i + 1) % glucoseValues.length]);\n            bgEvent3(bgTimeC, glucoseValues[(i + 2) % glucoseValues.length], bgFreqs[(i + 2) % glucoseValues.length]);\n            timbreShift(bgTimeC, fmSynth3, 1.5, fmMIOffset * bgRange01[(i + 2) % glucoseValues.length]);\n            bgEvent4(bgTime, glucoseValues[i], bgFreqs[i] * 0.125);\n        //bgVisEvent2(bgTime2, bgRange01[i], bgRange01[i+1], bgRange9[i+2], bgRange9[i+7], bgRange01[i+3], bgRange310[i+4], bgRange100[i+5], bgRange300[i+6])\n        // bgVisEvent2(bgTime, bgRange01[i], bgRange01[i], bgRange9[i],bgRange9[i], bgRange01[i], bgRange310[i], bgRange100[i], bgRange300[i])\n        } else if (bg < 4.0) {\n            console.log(\"low \", glucoseValues[i], bgTime, bgFreqs[i]);\n            //do something here\n            swellFMEvent1(bgTime, bgFreqs[i] * 0.125, bgRange01[i], bgRange01[i] * 2);\n            bgEvent(bgTime, glucoseValues[i], bgFreqs[i]);\n            timbreShift(bgTime, fmSynth, 1.5, fmMIOffset * bgRange01[i]);\n            bgEvent2(bgTimeB, glucoseValues[(i + 1) % glucoseValues.length], bgFreqs[(i + 1) % glucoseValues.length]);\n            timbreShift(bgTimeB, fmSynth2, 1.5, fmMIOffset * bgRange01[(i + 1) % glucoseValues.length]);\n            bgEvent3(bgTimeC, glucoseValues[(i + 2) % glucoseValues.length], bgFreqs[(i + 2) % glucoseValues.length]);\n            timbreShift(bgTimeC, fmSynth3, 1.5, fmMIOffset * bgRange01[(i + 2) % glucoseValues.length]);\n            bgEvent4(bgTime, glucoseValues[i], bgFreqs[i] * 0.125);\n        //bgVisEvent2(bgTime2, bgRange01[i], bgRange01[i+1], bgRange9[i+2], bgRange9[i+7], bgRange01[i+3], bgRange310[i+4], bgRange100[i+5], bgRange300[i+6])\n        // bgVisEvent2(bgTime, bgRange01[i], bgRange01[i], bgRange9[i],bgRange9[i], bgRange01[i], bgRange310[i], bgRange100[i], bgRange300[i])\n        }\n        //differences in timing for different streams of events\n        //multiplication factor determines how long to wait before changing\n        //addition in the bracket determines offset of BG value from dataset\n        bgTime = bgTime + glucoseValues[i] * 1;\n        bgTimeB = bgTimeB + glucoseValues[(i + 1) % glucoseValues.length] * 1; //need the modulo because of the offset (i+1), so it can wrap back around\n        bgTimeC = bgTimeC + glucoseValues[(i + 2) % glucoseValues.length] * 1; //need the modulo because of the offset (i+2), so it can wrap back around\n        bgTime2 = bgTime2 + glucoseValues[i] * 3;\n        console.log(\"bgTimeB\" + bgTimeB);\n        console.log(\"bgTimeC\" + bgTimeC);\n    }\n    console.log(\"bgTime\" + bgTime);\n    console.log(\"bgTimeB\" + bgTimeB);\n    console.log(\"bgTimeC\" + bgTimeC);\n    //console.log(calcBPM*bgTime*0.01667*0.25);\n    //console.log(calcBPM*bgTime*0.01667*0.25%Math.floor(calcBPM*bgTime*0.01667*0.25))\n    const bars = Math.floor(calcBPM * bgTime * 0.01667 * 0.25);\n    const beats = Math.floor(calcBPM * bgTime * 0.01667 * 0.25 % Math.floor(calcBPM * bgTime * 0.01667 * 0.25) * 4);\n    console.log(bars);\n    console.log(beats);\n    console.log(bars + \":\" + beats);\n    const endLoop = bars + \":\" + beats //4 + \":\" + 1;/*calcBPM*(bgTime+2.9+3.6+12)*0.01667*0.25*/\n    ;\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.setLoopPoints(0, endLoop);\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.loop = true;\n};\n// *  Scheduling\nconst playScheduling = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    //proof of concept - the bgData numbers are rounded off and uses as indices for the notesArray in the Tone.Sequence below\n    const bgData = [\n        5.7,\n        2.3,\n        11.8,\n        9.5,\n        7.8\n    ];\n    const notesArray = [\n        \"C3\",\n        \"A3\",\n        \"G3\",\n        \"E3\",\n        \"C2\",\n        \"C3\",\n        \"A3\",\n        \"G3\",\n        \"E3\",\n        \"C2\",\n        \"C3\",\n        \"A3\",\n        \"G3\",\n        \"E3\",\n        \"C2\"\n    ];\n    const synthA = new tone__WEBPACK_IMPORTED_MODULE_0__.FMSynth().toDestination();\n    const synthB = new tone__WEBPACK_IMPORTED_MODULE_0__.AMSynth().toDestination();\n    //play a note every quarter-note\n    /*const loopA = new Tone.Loop((time) => {\n    synthA.triggerAttackRelease('C2', '8n', time);\n  }, '4n').start(0);*/ const seq = new tone__WEBPACK_IMPORTED_MODULE_0__.Sequence((time, note)=>{\n        synthA.triggerAttackRelease(note, 0.1, time);\n    // subdivisions are given as subarrays\n    }, [\n        notesArray[Math.round(bgData[0])],\n        [\n            notesArray[1],\n            notesArray[2],\n            notesArray[3]\n        ],\n        notesArray[Math.round(bgData[3])],\n        [\n            notesArray[3],\n            notesArray[4]\n        ]\n    ]).start(0);\n    //play another note every off quarter-note, by starting it \"8n\"\n    const loopB = new tone__WEBPACK_IMPORTED_MODULE_0__.Loop((time)=>{\n        synthB.triggerAttackRelease(\"G2\", \"8n\", time);\n    }, \"4n\").start(\"8n\");\n    // all loops start until the Transport is started\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.bpm.value = 80;\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.start();\n    //Tone.Transport.start(\"+1\", \"2:0:0\");// this works\n    // schedule an event on the 2nd measure\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n        // invoked on measure 2\n        console.log(\"measure 2!\");\n        seq.stop();\n        //synthB.envelope.attack = 0.6;\n        synthB.set({\n            harmonicity: 0.1,\n            envelope: {\n                attack: 0.1,\n                release: 0.1\n            }\n        });\n    //Tone.Transport.bpm.value = 140;// not sure how to make this work properly\n    }, \"2:0:0\");\n    // schedule an event on the 4th measure\n    tone__WEBPACK_IMPORTED_MODULE_0__.Transport.schedule((time)=>{\n        // invoked on measure 2\n        // loopA.stop(time);\n        console.log(\"measure 4!\");\n        //synthB.setNote('F3');\n        seq.start();\n        //synthB.envelope.attack = 0.6;\n        synthB.harmonicity.rampTo(15, 2);\n    //synthB.harmonicity.value = 15;\n    }, \"4:0:0\");\n};\n//*  Instruments\nconst playInstruments = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    //pass in some initial values for the filter and filter envelope\n    const synth = new tone__WEBPACK_IMPORTED_MODULE_0__.PolySynth(tone__WEBPACK_IMPORTED_MODULE_0__.Synth).toDestination();\n    const now = tone__WEBPACK_IMPORTED_MODULE_0__.now();\n    synth.triggerAttack(\"D4\", now);\n    synth.triggerAttack(\"F4\", now + 0.5);\n    synth.triggerAttack(\"A4\", now + 1);\n    synth.triggerAttack(\"C4\", now + 1.5);\n    synth.triggerAttack(\"E4\", now + 2);\n    synth.triggerRelease([\n        \"D4\",\n        \"F4\",\n        \"A4\",\n        \"C4\",\n        \"E4\"\n    ], now + 4);\n};\n//*  Samples\nconst playSamples = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    const player = new tone__WEBPACK_IMPORTED_MODULE_0__.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n    tone__WEBPACK_IMPORTED_MODULE_0__.loaded().then(()=>{\n        player.start();\n    });\n};\n//*  Sampler\nconst playSampler = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    const sampler = new tone__WEBPACK_IMPORTED_MODULE_0__.Sampler({\n        urls: {\n            C4: \"C4.mp3\",\n            \"D#4\": \"Ds4.mp3\",\n            \"F#4\": \"Fs4.mp3\",\n            A4: \"A4.mp3\"\n        },\n        baseUrl: \"https://tonejs.github.io/audio/salamander/\"\n    }).toDestination();\n    tone__WEBPACK_IMPORTED_MODULE_0__.loaded().then(()=>{\n        sampler.triggerAttackRelease([\n            \"Eb4\",\n            \"G4\",\n            \"Bb4\"\n        ], 0.5);\n    });\n};\n//*  Efects\nconst playEffectts = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    const player = new tone__WEBPACK_IMPORTED_MODULE_0__.Player({\n        url: \"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\",\n        loop: false,\n        autostart: true\n    });\n    //create a distortion effect\n    const distortion = new tone__WEBPACK_IMPORTED_MODULE_0__.Distortion(0.4).toDestination();\n    //connect a player to the distortion\n    player.connect(distortion);\n};\n//*  Signals\nconst playSignal = async ()=>{\n    await tone__WEBPACK_IMPORTED_MODULE_0__.start();\n    const osc = new tone__WEBPACK_IMPORTED_MODULE_0__.Oscillator().toDestination();\n    // start at \"C4\"\n    osc.frequency.value = \"C4\";\n    // ramp to \"C5\" over 2 seconds\n    osc.frequency.rampTo(\"C5\", 2);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9mcm9udGVuZC9wbGF5Z3JvdW5kL1NvdW5kLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQzZCO0FBQ1E7QUFFRSxDQUFDLDhDQUE4QztBQUN0RDtBQUVoQyxzSUFBc0k7QUFDdEksb0ZBQW9GO0FBQ3BGLElBQUlJLGdCQUFnQkYsdURBQVcsQ0FBQyxDQUFDSSxRQUFVQSxNQUFNQyxPQUFPLEdBQUcsR0FBR0MsR0FBRyxDQUFDLENBQUNGLFFBQVVBLE1BQU1DLE9BQU87QUFDMUZILGdCQUFnQkEsY0FBY0MsTUFBTSxDQUFDSTtBQUNyQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCLE1BQU07QUFDTixxR0FBcUc7QUFDckcsSUFBSUMsYUFBYU4sY0FBY08sRUFBRSxDQUFDQyxLQUFLQyxLQUFLLENBQUNULGNBQWNVLE1BQU0sR0FBQztJQUkvQ1Y7QUFGbkIsWUFBWTtBQUNaLG9JQUFvSTtBQUNwSSxJQUFJVyxhQUFjLENBQUNYLENBQUFBLHdCQUFBQSxjQUFjWSxNQUFNLENBQUMsQ0FBQ0MsZUFBZUMsZUFBaUIsQ0FBQ0QsMEJBQUFBLDJCQUFBQSxnQkFBaUIsQ0FBQyxJQUFLQyxDQUFBQSx5QkFBQUEsMEJBQUFBLGVBQWdCLENBQUMsR0FBRyxnQkFBbEdkLG1DQUFBQSx3QkFBd0csQ0FBQyxJQUFFQSxjQUFjVSxNQUFNO0FBRWxKLFlBQVk7QUFDWixJQUFJSyxXQUFXLENBQUNQLEtBQUtRLEtBQUssQ0FBQ1YsYUFBVyxJQUFFLE1BQU1FLEtBQUtDLEtBQUssQ0FBQ0gsV0FBVSxJQUFHO0FBQ3RFLElBQUlXLFVBQVUsQ0FBQ1QsS0FBS1EsS0FBSyxDQUFDTCxhQUFXLElBQUUsTUFBTUgsS0FBS0MsS0FBSyxDQUFDRSxXQUFVLElBQUc7QUFDckUsSUFBSU8sV0FBVztBQUNmLElBQUlDLFdBQVc7SUFBQztJQUFLO0NBQUk7QUFFekIsWUFBWTtBQUNaLElBQUlDLFVBQVVDLGFBQWEsQ0FBQ2IsS0FBS1EsS0FBSyxDQUFDaEIsY0FBY08sRUFBRSxDQUFDVyxZQUFVLElBQUUsTUFBSVYsS0FBS0MsS0FBSyxDQUFDVCxjQUFjTyxFQUFFLENBQUNXLFVBQVMsSUFBRyxJQUFHO0lBQUM7SUFBRztDQUFHLEVBQUVDO0FBQzVIRyxRQUFRQyxHQUFHLENBQUMsY0FBY1I7QUFDMUJPLFFBQVFDLEdBQUcsQ0FBQyxhQUFhTjtBQUN6QkssUUFBUUMsR0FBRyxDQUFDLFdBQVdIO0FBRXZCLDBFQUEwRTtBQUMxRSxJQUFJSSxlQUFlLEVBQUU7QUFDckIsSUFBSUMsWUFBWWpCLEtBQUtDLEtBQUssQ0FBQ1QsY0FBY1UsTUFBTSxHQUFDO0FBQ2hELElBQUlnQixhQUFhMUIsY0FBYzJCLEtBQUssQ0FBQyxHQUFHRjtBQUN4QyxJQUFJRyxhQUFhNUIsY0FBYzJCLEtBQUssQ0FBQ0YsV0FBV0EsWUFBVTtBQUMxRCxJQUFJSSxhQUFhN0IsY0FBYzJCLEtBQUssQ0FBQ0YsWUFBVTtBQUMvQyxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUwsV0FBV0ssSUFBSTtJQUNqQ04sYUFBYU8sSUFBSSxDQUFDTCxVQUFVLENBQUNJLEVBQUUsRUFBRUYsVUFBVSxDQUFDRSxFQUFFLEVBQUVELFVBQVUsQ0FBQ0MsRUFBRTtBQUM3RDtBQUNBUixRQUFRQyxHQUFHLENBQUMsV0FBV0M7QUFDdkJGLFFBQVFDLEdBQUcsQ0FBQyxTQUFTdkI7QUFDdkIsa0NBQWtDO0FBRWxDLHFHQUFxRztBQUNyRyxzRkFBc0Y7QUFDdEYsU0FBU3FCLGFBQWFuQixLQUFLLEVBQUU4QixFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUNuQyxPQUFPLENBQUMvQixRQUFROEIsRUFBRSxDQUFDLEVBQUUsSUFBS0MsQ0FBQUEsRUFBRSxDQUFDLEVBQUUsR0FBR0EsRUFBRSxDQUFDLEVBQUUsSUFBS0QsQ0FBQUEsRUFBRSxDQUFDLEVBQUUsR0FBR0EsRUFBRSxDQUFDLEVBQUUsSUFBSUMsRUFBRSxDQUFDLEVBQUU7QUFDcEU7QUFDQSxNQUFNQyxRQUFRMUIsS0FBSzJCLEdBQUcsSUFBSW5DO0FBQzFCLE1BQU1vQyxRQUFRNUIsS0FBSzZCLEdBQUcsSUFBSXJDO0FBRTFCLDJFQUEyRTtBQUMzRSxNQUFNc0MsWUFBWXRDLGNBQWNJLEdBQUcsQ0FBQyxDQUFDbUMsTUFBUWxCLGFBQWFrQixLQUFLO1FBQUNIO1FBQU9GO0tBQU0sRUFBQztRQUFDO1FBQUU7S0FBRTtBQUNuRixNQUFNTSxXQUFXeEMsY0FBY0ksR0FBRyxDQUFDLENBQUNtQyxNQUFRbEIsYUFBYWtCLEtBQUs7UUFBQ0g7UUFBT0Y7S0FBTSxFQUFDO1FBQUM7UUFBRTtLQUFFO0FBQ2xGLE1BQU1PLGFBQWF6QyxjQUFjSSxHQUFHLENBQUMsQ0FBQ21DLE1BQVFsQixhQUFha0IsS0FBSztRQUFDSDtRQUFPRjtLQUFNLEVBQUM7UUFBQztRQUFPO0tBQUs7QUFDNUYsTUFBTVEsYUFBYTFDLGNBQWNJLEdBQUcsQ0FBQyxDQUFDbUMsTUFBUWxCLGFBQWFrQixLQUFLO1FBQUNIO1FBQU9GO0tBQU0sRUFBQztRQUFDO1FBQUs7S0FBSTtBQUN6RixNQUFNUyxhQUFhM0MsY0FBY0ksR0FBRyxDQUFDLENBQUNtQyxNQUFRbEIsYUFBYWtCLEtBQUs7UUFBQ0g7UUFBT0Y7S0FBTSxFQUFDO1FBQUM7UUFBTztLQUFJO0FBRzNGLCtGQUErRjtBQUMvRixNQUFNVSxlQUFlO0lBQUM7SUFBRTtJQUFFO0lBQUU7SUFBRTtJQUFFO0lBQUU7Q0FBRztBQUNyQyxNQUFNQyxZQUFZO0lBQUM7SUFBUTtJQUFTO0lBQVc7SUFBUztJQUFhO0lBQVU7Q0FBVTtBQUN6RixNQUFNQyxZQUFZL0I7QUFDbEIsTUFBTWdDLFFBQVE5QjtBQUNkLE1BQU0rQixnQkFBZ0JDLGdCQUFnQkwsY0FBY0UsV0FBV0MsT0FBTztBQUV0RSxnU0FBZ1M7QUFDaFMsU0FBU0UsZ0JBQWdCQyxrQkFBa0IsRUFBRUMsT0FBTyxFQUE4QjtRQUE1QkMsT0FBQUEsaUVBQU8sQ0FBQyxFQUFFQyxnQkFBQUEsaUVBQWMsQ0FBQztJQUM3RSxJQUFJQyxhQUFhO0lBQ2pCLElBQUlDLGNBQWMsRUFBRTtJQUNwQixJQUFJQztJQUNKLElBQUksSUFBSTFCLElBQUUsR0FBR0EsSUFBRW9CLG1CQUFtQnhDLE1BQU0sR0FBQzJDLGVBQWV2QixJQUFLO1FBQzNEd0IsYUFBYSxDQUFDeEIsSUFBRXFCLE9BQU0sSUFBS0QsbUJBQW1CeEMsTUFBTTtRQUNwRDhDLGVBQWUsQ0FBQ04sa0JBQWtCLENBQUNJLFdBQVcsR0FBR0osa0JBQWtCLENBQUNDLFFBQVEsR0FBRSxFQUFDLElBQUs7UUFDckZLLGVBQWVBLGVBQWVKLE9BQU81QyxLQUFLQyxLQUFLLENBQUNxQixJQUFFb0IsbUJBQW1CeEMsTUFBTSxJQUFFO1FBQzVFNkMsWUFBWXhCLElBQUksQ0FBQ3lCO0lBRW5CO0lBQ0FsQyxRQUFRQyxHQUFHLENBQUMsVUFBUXNCLFNBQVMsQ0FBQ00sUUFBUSxHQUFDLGNBQVlJLFlBQVlFLFFBQVE7SUFDdkUsT0FBT0Y7QUFDVDtBQUVBLGlEQUFpRDtBQUNqRCx5UUFBeVE7QUFDelEsc0NBQXNDO0FBQ3RDLFNBQVNHLGlCQUFpQkgsV0FBcUIsRUFBRUksVUFBVSxFQUFnQjtRQUFkQyxhQUFBQSxpRUFBVyxDQUFDO0lBQ3ZFLElBQUlDO0lBQ0osSUFBSUM7SUFDSkQsY0FBYzdELGNBQWNJLEdBQUcsQ0FBQyxDQUFDbUMsTUFBUS9CLEtBQUtRLEtBQUssQ0FBQ0ssYUFBYWtCLEtBQUs7WUFBQ0g7WUFBT0Y7U0FBTSxFQUFDO1lBQUM7WUFBR3lCLGFBQVc7U0FBRTtJQUN0R0csY0FBY0QsWUFBWXpELEdBQUcsQ0FBQyxDQUFDbUMsTUFBTWdCLFdBQVcsQ0FBQ2hCLElBQUksR0FBQ3FCLGFBQVc7SUFDakUsT0FBT0U7QUFDUDtBQUlGLGtFQUFrRTtBQUNsRSxNQUFNQyxVQUFVLElBQUluRSx3Q0FBVyxDQUFDO0FBRWhDLE1BQU1xRSxXQUFXLElBQUlyRSx3Q0FBVyxDQUFDLENBQUMsS0FBSyxHQUFHdUUsYUFBYTtBQUN2RCxNQUFNQyxXQUFXLElBQUl4RSx3Q0FBVyxDQUFDLEtBQUssR0FBR3VFLGFBQWE7QUFDdEQsTUFBTUUsV0FBVyxJQUFJekUsd0NBQVcsQ0FBQyxHQUFHLEdBQUd1RSxhQUFhO0FBQ3BELE1BQU1HLFdBQVcsSUFBSTFFLHdDQUFXLENBQUMsR0FBRyxDQUFDLEdBQUd1RSxhQUFhO0FBRXJELE1BQU1JLFlBQVksSUFBSTNFLCtDQUFrQjtBQUV4QyxNQUFNNkUsUUFBUSxJQUFJN0UsNENBQWU7QUFDakMsTUFBTStFLFNBQVMsSUFBSS9FLDRDQUFlO0FBQ2xDLE1BQU1nRixTQUFTLElBQUloRiw0Q0FBZTtBQUVsQyxNQUFNaUYsVUFBVSxJQUFJakYseUNBQVk7QUFDaEMsTUFBTW1GLFdBQVcsSUFBSW5GLHlDQUFZO0FBQ2pDLE1BQU1vRixXQUFXLElBQUlwRix5Q0FBWTtBQUVqQyxNQUFNcUYsYUFBYTtBQUVuQixNQUFNQyxVQUFVLElBQUl0Rix5Q0FBWTtBQUNoQ3NGLFFBQVFDLEdBQUcsQ0FBQztJQUNWQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsVUFBVTtRQUFDQyxRQUFRO0lBQUk7SUFDdkJDLG9CQUFvQjtRQUFDRCxRQUFRO1FBQzdCRSxPQUFPO1FBQ1BDLFNBQVM7SUFBRztJQUNaQyxZQUFZO1FBQUNDLE1BQU07SUFBVztJQUM5QkMsWUFBWTtRQUFDRCxNQUFNO0lBQVk7QUFFL0I7QUFFRm5CLE1BQU1xQixPQUFPLENBQUM3QjtBQUNkUSxNQUFNc0IsS0FBSyxDQUFDaEMsU0FBU25FLDZDQUFnQjtBQUNyQytFLE9BQU9tQixPQUFPLENBQUMxQjtBQUNmTyxPQUFPb0IsS0FBSyxDQUFDaEMsU0FBU25FLDZDQUFnQjtBQUN0Q2dGLE9BQU9rQixPQUFPLENBQUN6QjtBQUNmTyxPQUFPbUIsS0FBSyxDQUFDaEMsU0FBU25FLDZDQUFnQjtBQUV0Q2lGLFFBQVFpQixPQUFPLENBQUM3QjtBQUNoQlksUUFBUWtCLEtBQUssQ0FBQ2hDLFNBQVNuRSw2Q0FBZ0I7QUFDdkNtRixTQUFTZSxPQUFPLENBQUMxQjtBQUNqQlcsU0FBU2dCLEtBQUssQ0FBQ2hDLFNBQVNuRSw2Q0FBZ0I7QUFDeENvRixTQUFTYyxPQUFPLENBQUN6QjtBQUNqQlcsU0FBU2UsS0FBSyxDQUFDaEMsU0FBU25FLDZDQUFnQjtBQUV4Q3NGLFFBQVFZLE9BQU8sQ0FBQzdCO0FBQ2hCaUIsUUFBUWEsS0FBSyxDQUFDaEMsU0FBU25FLDZDQUFnQjtBQUV2QzJFLFVBQVV1QixPQUFPLENBQUN4QjtBQUlsQixXQUFXO0FBQ0osTUFBTTJCLGFBQWEsVUFBWTtJQUNwQyxNQUFNckcsdUNBQVU7SUFDaEIsWUFBWTtJQUNaMEIsUUFBUUMsR0FBRyxDQUFDdkIsY0FBY0ksR0FBRyxDQUFDK0YsQ0FBQUEsSUFBSUEsSUFBSTtJQUN0QyxvQkFBb0I7SUFDcEIsbURBQW1EO0lBQ25EdEcsMkNBQWE7SUFDYixtREFBbUQ7SUFDcEQsdUJBQXVCO0lBQ3hCQSx5Q0FBVyxDQUFDRyxjQUFjSSxHQUFHLENBQUMrRixDQUFBQSxJQUFJQSxJQUFJLEtBQUtuRyxlQUFlLEtBQUs7SUFDN0R5RSxNQUFNNEIsb0JBQW9CLENBQUMsTUFBTTtJQUNuQyxZQUFZO0lBQ1gsSUFBSyxJQUFJdkUsSUFBSSxHQUFHQSxJQUFJaEMsdURBQVcsRUFBRWdDLElBQ2xDO1FBQ0UsSUFBSXdFLEtBQUt4RyxnREFBSSxDQUFDZ0MsRUFBRSxDQUFDM0IsT0FBTztRQUN4QixJQUFJbUcsTUFBTSxLQUFJO1lBQ1poRixRQUFRQyxHQUFHLENBQUMsU0FBU08sR0FBR2hDLGdEQUFJLENBQUNnQyxFQUFFLENBQUMzQixPQUFPO1FBQ3ZDLG1CQUFtQjtRQUNyQixPQUNBLElBQUltRyxNQUFLLE9BQU9BLE1BQUksS0FBSztZQUN2QmhGLFFBQVFDLEdBQUcsQ0FBQyxXQUFXTyxHQUFHaEMsZ0RBQUksQ0FBQ2dDLEVBQUUsQ0FBQzNCLE9BQU87UUFDekMsbUJBQW1CO1FBQ3JCLE9BQ0EsSUFBSW1HLEtBQUssS0FBSTtZQUNYaEYsUUFBUUMsR0FBRyxDQUFDLFFBQVFPLEdBQUdoQyxnREFBSSxDQUFDZ0MsRUFBRSxDQUFDM0IsT0FBTztRQUN0QyxtQkFBbUI7UUFDckIsQ0FBQztJQUNIO0FBSUEsRUFBRTtBQUVGLGtCQUFrQjtBQUNYLE1BQU1vRyxrQkFBa0IsVUFBWTtJQUN6QyxNQUFNM0csdUNBQVU7SUFDaEIsTUFBTTRHLE1BQU01RyxxQ0FBUTtJQUNwQixpQ0FBaUM7SUFDakMsa0NBQWtDO0lBQ2xDLGdEQUFnRDtJQUNoRCxrQ0FBa0M7SUFDbEM2RSxNQUFNNEIsb0JBQW9CLENBQUMsTUFBTSxNQUFNRyxNQUFNLEdBQUc7QUFDbEQsRUFBRTtBQUVGLGFBQWE7QUFFTixNQUFNQyxjQUFjLFVBQVk7SUFDckMsTUFBTTdHLHVDQUFVO0lBRWxCLDBGQUEwRjtJQUN4RixNQUFNOEcsTUFBTSxJQUFJOUcscUNBQVEsQ0FBQztJQUMzQnNGLFFBQVFZLE9BQU8sQ0FBQ1k7SUFDaEJBLElBQUl2QixHQUFHLENBQUM7UUFDTnlCLGFBQWEsSUFBSTtRQUNqQkMsV0FBVztJQUNiO0lBQ0MsSUFBSUMsZUFBZTtJQUNuQixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLGVBQWU7SUFDbkIsTUFBTUMsU0FBU3ZELGlCQUFpQlYsZUFBZUosYUFBYWxDLE1BQU0sR0FBQyxHQUFHO0lBQ3RFLE1BQU13RyxVQUFVRCxPQUFPN0csR0FBRyxDQUFDLENBQUNtQyxNQUFNM0Msc0NBQVMsQ0FBQzJDO0lBQzVDakIsUUFBUUMsR0FBRyxDQUFDMkY7SUFDWnJILDJDQUFhO0lBQ2Isc0VBQXNFO0lBQ3RFLHFCQUFxQjtJQUNyQkEseUNBQVcsQ0FBQ3lDLFdBQVcrRTtJQUN2QixpQkFBaUI7SUFDakIsc0JBQXNCO0lBQ3RCLG9CQUFvQjtJQUNwQixrQkFBa0I7SUFFakIsbUhBQW1IO0lBQ25ILFNBQVNDLFVBQVVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDMUIsa0RBQWtEO1FBQ2xELElBQUlDLE1BQU0zSCxtREFBTyxDQUFDd0gsR0FBR3hILHNEQUFVLENBQUM7WUFBQztTQUFFLEdBQUc4SCxNQUFNLENBQUM5SCxtREFBTyxDQUFDeUgsSUFBSUQsR0FBR3hILHNEQUFVLENBQUM7WUFBQztTQUFFO1FBQzFFLGtGQUFrRjtRQUNsRixNQUFPLElBQUksQ0FBRTtZQUNYLHVEQUF1RDtZQUN2RCxJQUFJLENBQUMrSCxNQUFNQyxVQUFVLEdBQUdoSSx1REFBVyxDQUFDMkgsS0FBSzVGLENBQUFBLElBQUsvQixxREFBUyxDQUFDK0IsR0FBRzRGLEdBQUcsQ0FBQyxFQUFFO1lBQ2pFLG9DQUFvQztZQUNwQyxJQUFJSyxVQUFVckgsTUFBTSxHQUFHLEdBQUcsS0FBTTtZQUNoQyxJQUFLLElBQUlvQixJQUFJLEdBQUdBLElBQUl0QixLQUFLNkIsR0FBRyxDQUFDeUYsS0FBS3BILE1BQU0sRUFBRXFILFVBQVVySCxNQUFNLEdBQUdvQixJQUFLO2dCQUNoRTRGLEdBQUcsQ0FBQzVGLEVBQUUsR0FBRzRGLEdBQUcsQ0FBQzVGLEVBQUUsQ0FBQytGLE1BQU0sQ0FBQ0gsSUFBSVEsR0FBRztZQUNoQztRQUNGO1FBQ0QsT0FBT25JLHFEQUFTLENBQUMySCxLQUFLdEgsR0FBRyxDQUFDLFNBQVNGLEtBQUssRUFBQztZQUFDLElBQUdBLFNBQVMsR0FBRTtnQkFBQyxPQUFPdUg7WUFBQyxPQUFLO2dCQUFDLE9BQU8sSUFBSTtZQUFBLENBQUM7UUFBQTtJQUNwRjtJQUVGLElBQUlXLFFBQVEsRUFBRTtJQUNkLElBQUlDLFNBQVMsRUFBRTtJQUNmLElBQUlDLFNBQVMsRUFBRTtJQUNmLElBQUlDLE9BQU8sRUFBRTtJQUliLGlEQUFpRDtJQUNqRCxNQUFNQyxZQUFZLElBQUk1SSwwQ0FBYSxDQUNqQyxTQUFTOEksSUFBSSxFQUFFQyxJQUFJLEVBQUU7UUFDbkI5RCxRQUFRd0Isb0JBQW9CLENBQUNzQyxNQUFNLE9BQU9ELE1BQU1wRyxTQUFTLENBQUN3RSxlQUFheEUsVUFBVTVCLE1BQU0sQ0FBQztRQUN4RlksUUFBUUMsR0FBRyxDQUFDO1FBQ1osdUVBQXVFO1FBQ3JFLDRGQUE0RjtRQUMvRjs7Ozs7Ozs7O1NBU00sR0FDTHVGO0lBQ0YsR0FDQXNCLE9BQ0E7SUFHRixpREFBaUQ7SUFDakQsTUFBTVEsYUFBYSxJQUFJaEosMENBQWEsQ0FDbEMsU0FBUzhJLElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ3JCNUQsU0FBU3NCLG9CQUFvQixDQUFDc0MsTUFBTSxPQUFPRCxNQUFNcEcsU0FBUyxDQUFDeUUsZUFBYXpFLFVBQVU1QixNQUFNLENBQUM7UUFDekZZLFFBQVFDLEdBQUcsQ0FBQztRQUNWd0Y7SUFDRixHQUNBc0IsUUFDQTtJQUdGLGlEQUFpRDtJQUNqRCxNQUFNUSxhQUFhLElBQUlqSiwwQ0FBYSxDQUNsQyxTQUFTOEksSUFBSSxFQUFFQyxJQUFJLEVBQUU7UUFDbkIzRCxTQUFTcUIsb0JBQW9CLENBQUNzQyxNQUFNLE9BQU9ELE1BQU1wRyxTQUFTLENBQUMwRSxlQUFhMUUsVUFBVTVCLE1BQU0sQ0FBQztRQUN6RlksUUFBUUMsR0FBRyxDQUFDO1FBQ1p5RjtJQUNGLEdBQ0FzQixRQUNBO0lBR0YsaURBQWlEO0lBQ2pELE1BQU1RLFdBQVcsSUFBSWxKLDBDQUFhLENBQ2hDLFNBQVM4SSxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUNuQnBFLFVBQVU4QixvQkFBb0IsQ0FBQ3NDLE1BQU0sT0FBT0Q7SUFDOUMsR0FDQUgsTUFDQTtJQUdGLGdEQUFnRDtJQUNoREMsVUFBVXRDLEtBQUs7SUFDZjBDLFdBQVcxQyxLQUFLO0lBQ2hCMkMsV0FBVzNDLEtBQUs7SUFDaEI0QyxTQUFTNUMsS0FBSztJQUVkLHNEQUFzRDtJQUN0RCw4Q0FBOEM7SUFDOUMsMEdBQTBHO0lBQzFHLHFDQUFxQztJQUNyQ3RHLHFEQUF3QixHQUFHd0I7SUFDM0J4QixpREFBb0I7SUFFcEIsaUhBQWlIO0lBQ2pILFNBQVNxSixjQUFlQyxDQUFDLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFBQ3pKLG9EQUF1QixDQUFDLENBQUM4SSxPQUFPO1lBQzVFeEQsUUFBUW1CLG9CQUFvQixDQUFDOEMsTUFBTUU7WUFDbkNuRSxRQUFRQyxHQUFHLENBQUM7Z0JBQ1ZDLGFBQWE7Z0JBQ2JDLGlCQUFpQjtnQkFDakJDLFVBQVU7b0JBQUNDLFFBQVE2RDtnQkFBRztnQkFDdEI1RCxvQkFBb0I7b0JBQUNELFFBQVE2RDtvQkFDN0IzRCxPQUFPO29CQUNQQyxTQUFTO2dCQUFHO2dCQUNaQyxZQUFZO29CQUFDQyxNQUFNO2dCQUFXO2dCQUM5QkMsWUFBWTtvQkFBQ0QsTUFBTTtnQkFBWTtZQUMvQjtRQUNGLEdBQUdzRDtJQUFHO0lBRU4sU0FBU0ssWUFBWUwsQ0FBQyxFQUFFTSxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQUM5SixvREFBdUIsQ0FBQyxDQUFDOEksT0FBTztZQUNwRmMsVUFBVXJFLEdBQUcsQ0FBQztnQkFDWkMsYUFBYXFFO2dCQUNicEUsaUJBQWlCcUU7Z0JBQ2pCcEUsVUFBVTtvQkFBQ0MsUUFBUTtvQkFDakJFLE9BQU87Z0JBQUs7Z0JBQ1pELG9CQUFvQjtvQkFBQ0QsUUFBUTtvQkFDN0JFLE9BQU87b0JBQ1BDLFNBQVM7Z0JBQUM7Z0JBQ1ZDLFlBQVk7b0JBQUNDLE1BQU07Z0JBQU07Z0JBQ3pCQyxZQUFZO29CQUFDRCxNQUFNO2dCQUFNO1lBQzNCO1FBQ0YsR0FBR3NEO0lBQUc7SUFFUix3SkFBd0o7SUFDeEoscUVBQXFFO0lBQ3JFLFNBQVNTLFFBQVNULENBQUMsRUFBRTFCLENBQUMsRUFBRTJCLElBQUksRUFBRTtRQUFFdkosb0RBQXVCLENBQUMsQ0FBQzhJLE9BQVM7WUFDaEVGLFVBQVVvQixNQUFNLEdBQUd0QyxVQUFVdUMsV0FBV3JDLElBQUlzQyxXQUFXdEMsSUFBSTJCO1lBQzNEN0gsUUFBUUMsR0FBRyxDQUFDaUgsVUFBVW9CLE1BQU07WUFDNUJ0SSxRQUFRQyxHQUFHLENBQUNpRztZQUNaNUgsK0NBQWtCLENBQUMsSUFBTTtZQUN6QixzQ0FBc0M7WUFDckMsb0lBQW9JO1lBQ3RJLHFDQUFxQztZQUNuQyxvQkFBb0I7WUFDdEIsR0FBRzhJO1FBQ0osR0FBR1E7SUFBRztJQUVOLGtIQUFrSDtJQUNsSCx3RkFBd0Y7SUFDeEYsU0FBUzdCLFVBQVU7UUFBQyxJQUFJMkMsSUFBS3RELElBQUl1RCxRQUFRO1FBQUksT0FBT0QsQ0FBQyxDQUFDLEVBQUUsR0FBQztJQUFFO0lBRTNELHdKQUF3SjtJQUN4SixTQUFTRSxTQUFVaEIsQ0FBQyxFQUFFMUIsQ0FBQyxFQUFFMkIsSUFBSSxFQUFFO1FBQUV2SixvREFBdUIsQ0FBQyxDQUFDOEksT0FBUztZQUNqRUUsV0FBV2dCLE1BQU0sR0FBR3RDLFVBQVV1QyxXQUFXckMsSUFBSXNDLFdBQVd0QyxJQUFJMkI7WUFDNUQ3SCxRQUFRQyxHQUFHLENBQUNxSCxXQUFXZ0IsTUFBTTtZQUM3QnRJLFFBQVFDLEdBQUcsQ0FBQ2lHO1lBQ1o1SCwrQ0FBa0IsQ0FBQyxJQUFNO1lBQ3pCLHNDQUFzQztZQUNyQyxvSUFBb0k7WUFDdkksa0JBQWtCO1lBQ2Ysb0JBQW9CO1lBQ3RCLEdBQUc4STtRQUNKLEdBQUdRO0lBQUc7SUFFTix3SkFBd0o7SUFDeEosU0FBU2lCLFNBQVVqQixDQUFDLEVBQUUxQixDQUFDLEVBQUUyQixJQUFJLEVBQUU7UUFBRXZKLG9EQUF1QixDQUFDLENBQUM4SSxPQUFTO1lBQ2pFRyxXQUFXZSxNQUFNLEdBQUd0QyxVQUFVdUMsV0FBV3JDLElBQUlzQyxXQUFXdEMsSUFBSTJCO1lBQzVEN0gsUUFBUUMsR0FBRyxDQUFDc0gsV0FBV2UsTUFBTTtZQUM3QnRJLFFBQVFDLEdBQUcsQ0FBQ2lHO1lBQ1o1SCwrQ0FBa0IsQ0FBQyxJQUFNO1lBQ3pCLHNDQUFzQztZQUNyQyxvSUFBb0k7WUFDdkksbUJBQW1CO1lBQ2hCLG9CQUFvQjtZQUN0QixHQUFHOEk7UUFDSixHQUFHUTtJQUFHO0lBRU4sd0pBQXdKO0lBQ3hKLFNBQVNrQixTQUFVbEIsQ0FBQyxFQUFFMUIsQ0FBQyxFQUFFMkIsSUFBSSxFQUFFO1FBQUV2SixvREFBdUIsQ0FBQyxDQUFDOEksT0FBUztZQUNqRUksU0FBU2MsTUFBTSxHQUFHdEMsVUFBVXVDLFdBQVdyQyxJQUFJc0MsV0FBV3RDLElBQUkyQjtZQUMxRDdILFFBQVFDLEdBQUcsQ0FBQ3VILFNBQVNjLE1BQU07WUFDM0J0SSxRQUFRQyxHQUFHLENBQUNpRztZQUNaNUgsK0NBQWtCLENBQUMsSUFBTTtZQUN6QixzQ0FBc0M7WUFDckMsb0lBQW9JO1lBQ3ZJLG1CQUFtQjtZQUNoQixvQkFBb0I7WUFDdEIsR0FBRzhJO1FBQ0osR0FBR1E7SUFBRztJQUVOLG1LQUFtSztJQUNuSyxTQUFTVyxXQUFZckMsQ0FBQyxFQUFDO1FBQ3JCLE9BQU9oSCxLQUFLNkIsR0FBRyxDQUFDN0IsS0FBS1EsS0FBSyxDQUFDd0csSUFBRSxJQUFFLEtBQUtoSCxLQUFLQyxLQUFLLENBQUMrRztJQUNqRDtJQUNBLFNBQVNzQyxXQUFZdEMsQ0FBQyxFQUFDO1FBQ3JCLE9BQU9oSCxLQUFLMkIsR0FBRyxDQUFDM0IsS0FBS1EsS0FBSyxDQUFDd0csSUFBRSxJQUFFLEtBQUtoSCxLQUFLQyxLQUFLLENBQUMrRztJQUNqRDtJQUVBLGdEQUFnRDtJQUNoRCx3REFBd0Q7SUFDeEQsU0FBUzZDLFdBQVluQixDQUFDLEVBQUU7UUFBRXRKLG9EQUF1QixDQUFDLENBQUM4SSxPQUFTO1lBQ3hEOUksK0NBQWtCLENBQUMsSUFBTTtnQkFDM0Isc0NBQXNDO2dCQUN2Q0MseUNBQVc7Z0JBQ1R5QixRQUFRQyxHQUFHLENBQUNtSDtZQUNkLEdBQUdBO1FBQ0osR0FBR1E7SUFBRztJQUVOLGdEQUFnRDtJQUNoRCx3REFBd0Q7SUFDeEQsU0FBU29CLFlBQWFwQixDQUFDLEVBQUVxQixDQUFDLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRTtRQUFFbEwsb0RBQXVCLENBQUMsQ0FBQzhJLE9BQVM7WUFDbkc5SSwrQ0FBa0IsQ0FBQyxJQUFNO2dCQUN6QixzQ0FBc0M7Z0JBQ3hDQyx5Q0FBVyxDQUFDMEssR0FBR0MsS0FBS0MsS0FBS0MsSUFBSUMsSUFBSUMsS0FBS0MsUUFBUUM7Z0JBQzdDeEosUUFBUUMsR0FBRyxDQUFDbUg7WUFDYixHQUFHQTtRQUNILEdBQUdRO0lBQUc7SUFFTiw2SkFBNko7SUFDN0osZ0dBQWdHO0lBQ2hHLDBGQUEwRjtJQUcxRiw2UEFBNlA7SUFDN1AsME5BQTBOO0lBQzFOLElBQUk4QixTQUFTO0lBQ2IsSUFBSUMsVUFBVSxHQUFHLDRHQUE0RztJQUM3SCxJQUFJQyxVQUFVLEdBQUcsNEdBQTRHO0lBQzdILElBQUlDLFVBQVU7SUFDZCx3QkFBd0I7SUFDeEIsSUFBSyxJQUFJckosSUFBSSxHQUFHQSxJQUFJOUIsY0FBY1UsTUFBTSxFQUFFb0IsSUFDMUM7UUFDRSxJQUFJd0UsS0FBS3RHLGFBQWEsQ0FBQzhCLEVBQUU7UUFDekIsNE1BQTRNO1FBQzVNLElBQUl3RSxNQUFNLEtBQUk7WUFDWmhGLFFBQVFDLEdBQUcsQ0FBQyxTQUFTdkIsYUFBYSxDQUFDOEIsRUFBRSxFQUFFa0osUUFBUTlELE9BQU8sQ0FBQ3BGLEVBQUU7WUFDekQsbUJBQW1CO1lBQ25CLHNJQUFzSTtZQUN0SW1ILGNBQWMrQixRQUFROUQsT0FBTyxDQUFDcEYsRUFBRSxHQUFDLE9BQU9RLFNBQVMsQ0FBQ1IsRUFBRSxFQUFFUSxTQUFTLENBQUNSLEVBQUUsR0FBQztZQUNuRSw2TEFBNkw7WUFDN0w2SCxRQUFRcUIsUUFBUWhMLGFBQWEsQ0FBQzhCLEVBQUUsRUFBRW9GLE9BQU8sQ0FBQ3BGLEVBQUU7WUFDNUN5SCxZQUFZeUIsUUFBUW5HLFNBQVMsS0FBS0ksYUFBVzNDLFNBQVMsQ0FBQ1IsRUFBRTtZQUN6RG9JLFNBQVNlLFNBQVNqTCxhQUFhLENBQUMsQ0FBQzhCLElBQUUsS0FBRzlCLGNBQWNVLE1BQU0sQ0FBQyxFQUFFd0csT0FBTyxDQUFDLENBQUNwRixJQUFFLEtBQUc5QixjQUFjVSxNQUFNLENBQUM7WUFDaEc2SSxZQUFZMEIsU0FBU2xHLFVBQVUsS0FBS0UsYUFBVzNDLFNBQVMsQ0FBQyxDQUFDUixJQUFFLEtBQUc5QixjQUFjVSxNQUFNLENBQUM7WUFDcEZ5SixTQUFTZSxTQUFTbEwsYUFBYSxDQUFDLENBQUM4QixJQUFFLEtBQUc5QixjQUFjVSxNQUFNLENBQUMsRUFBRXdHLE9BQU8sQ0FBQyxDQUFDcEYsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDO1lBQ2hHNkksWUFBWTJCLFNBQVNsRyxVQUFVLEtBQUtDLGFBQVczQyxTQUFTLENBQUMsQ0FBQ1IsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDO1lBQ3BGMEosU0FBU1ksUUFBUWhMLGFBQWEsQ0FBQzhCLEVBQUUsRUFBRW9GLE9BQU8sQ0FBQ3BGLEVBQUUsR0FBQztRQUNsRCx3SEFBd0g7UUFDeEgscUpBQXFKO1FBQ2pKLHFJQUFxSTtRQUN2SSxPQUNBLElBQUl3RSxNQUFLLE9BQU9BLE1BQUksS0FBSztZQUN2QmhGLFFBQVFDLEdBQUcsQ0FBQyxXQUFXdkIsYUFBYSxDQUFDOEIsRUFBRSxFQUFFa0osUUFBUTlELE9BQU8sQ0FBQ3BGLEVBQUU7WUFDM0QsbUJBQW1CO1lBQ3BCbUgsY0FBYytCLFFBQVE5RCxPQUFPLENBQUNwRixFQUFFLEdBQUMsT0FBT1EsU0FBUyxDQUFDUixFQUFFLEVBQUVRLFNBQVMsQ0FBQ1IsRUFBRSxHQUFDO1lBQ25FNkgsUUFBUXFCLFFBQVFoTCxhQUFhLENBQUM4QixFQUFFLEVBQUVvRixPQUFPLENBQUNwRixFQUFFO1lBQzVDeUgsWUFBWXlCLFFBQVFuRyxTQUFTLEtBQUtJLGFBQVczQyxTQUFTLENBQUNSLEVBQUU7WUFDekRvSSxTQUFTZSxTQUFTakwsYUFBYSxDQUFDLENBQUM4QixJQUFFLEtBQUc5QixjQUFjVSxNQUFNLENBQUMsRUFBRXdHLE9BQU8sQ0FBQyxDQUFDcEYsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDO1lBQ2hHNkksWUFBWTBCLFNBQVNsRyxVQUFVLEtBQUtFLGFBQVczQyxTQUFTLENBQUMsQ0FBQ1IsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDO1lBQ3BGeUosU0FBU2UsU0FBU2xMLGFBQWEsQ0FBQyxDQUFDOEIsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDLEVBQUV3RyxPQUFPLENBQUMsQ0FBQ3BGLElBQUUsS0FBRzlCLGNBQWNVLE1BQU0sQ0FBQztZQUNoRzZJLFlBQVkyQixTQUFTbEcsVUFBVSxLQUFLQyxhQUFXM0MsU0FBUyxDQUFDLENBQUNSLElBQUUsS0FBRzlCLGNBQWNVLE1BQU0sQ0FBQztZQUNwRjBKLFNBQVNZLFFBQVFoTCxhQUFhLENBQUM4QixFQUFFLEVBQUVvRixPQUFPLENBQUNwRixFQUFFLEdBQUM7UUFFOUMscUpBQXFKO1FBQ3RKLHNJQUFzSTtRQUN0SSxPQUNBLElBQUl3RSxLQUFLLEtBQUk7WUFDWGhGLFFBQVFDLEdBQUcsQ0FBQyxRQUFRdkIsYUFBYSxDQUFDOEIsRUFBRSxFQUFFa0osUUFBUTlELE9BQU8sQ0FBQ3BGLEVBQUU7WUFDeEQsbUJBQW1CO1lBQ25CbUgsY0FBYytCLFFBQVE5RCxPQUFPLENBQUNwRixFQUFFLEdBQUMsT0FBT1EsU0FBUyxDQUFDUixFQUFFLEVBQUVRLFNBQVMsQ0FBQ1IsRUFBRSxHQUFDO1lBRXBFNkgsUUFBUXFCLFFBQVFoTCxhQUFhLENBQUM4QixFQUFFLEVBQUVvRixPQUFPLENBQUNwRixFQUFFO1lBQzVDeUgsWUFBWXlCLFFBQVFuRyxTQUFTLEtBQUtJLGFBQVczQyxTQUFTLENBQUNSLEVBQUU7WUFDekRvSSxTQUFTZSxTQUFTakwsYUFBYSxDQUFDLENBQUM4QixJQUFFLEtBQUc5QixjQUFjVSxNQUFNLENBQUMsRUFBRXdHLE9BQU8sQ0FBQyxDQUFDcEYsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDO1lBQ2hHNkksWUFBWTBCLFNBQVNsRyxVQUFVLEtBQUtFLGFBQVczQyxTQUFTLENBQUMsQ0FBQ1IsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDO1lBQ3BGeUosU0FBU2UsU0FBU2xMLGFBQWEsQ0FBQyxDQUFDOEIsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDLEVBQUV3RyxPQUFPLENBQUMsQ0FBQ3BGLElBQUUsS0FBRzlCLGNBQWNVLE1BQU0sQ0FBQztZQUNoRzZJLFlBQVkyQixTQUFTbEcsVUFBVSxLQUFLQyxhQUFXM0MsU0FBUyxDQUFDLENBQUNSLElBQUUsS0FBRzlCLGNBQWNVLE1BQU0sQ0FBQztZQUNwRjBKLFNBQVNZLFFBQVFoTCxhQUFhLENBQUM4QixFQUFFLEVBQUVvRixPQUFPLENBQUNwRixFQUFFLEdBQUM7UUFDN0MscUpBQXFKO1FBQ3ZKLHNJQUFzSTtRQUN0SSxDQUFDO1FBQ0MsdURBQXVEO1FBQ3pELG1FQUFtRTtRQUNuRSxvRUFBb0U7UUFDcEVrSixTQUFTQSxTQUFTaEwsYUFBYSxDQUFDOEIsRUFBRSxHQUFDO1FBQ25DbUosVUFBVUEsVUFBVWpMLGFBQWEsQ0FBQyxDQUFDOEIsSUFBRSxLQUFHOUIsY0FBY1UsTUFBTSxDQUFDLEdBQUMsR0FBRSx5RUFBeUU7UUFDekl3SyxVQUFVQSxVQUFVbEwsYUFBYSxDQUFDLENBQUM4QixJQUFFLEtBQUc5QixjQUFjVSxNQUFNLENBQUMsR0FBQyxHQUFFLHlFQUF5RTtRQUN6SXlLLFVBQVVBLFVBQVVuTCxhQUFhLENBQUM4QixFQUFFLEdBQUM7UUFDckNSLFFBQVFDLEdBQUcsQ0FBQyxZQUFZMEo7UUFDMUIzSixRQUFRQyxHQUFHLENBQUMsWUFBWTJKO0lBQ3hCO0lBQ0E1SixRQUFRQyxHQUFHLENBQUMsV0FBV3lKO0lBQ3ZCMUosUUFBUUMsR0FBRyxDQUFDLFlBQVkwSjtJQUN4QjNKLFFBQVFDLEdBQUcsQ0FBQyxZQUFZMko7SUFDeEIsMkNBQTJDO0lBQzNDLGtGQUFrRjtJQUNsRixNQUFNRSxPQUFPNUssS0FBS0MsS0FBSyxDQUFDVyxVQUFTNEosU0FBUSxVQUFRO0lBQ2pELE1BQU1LLFFBQVE3SyxLQUFLQyxLQUFLLENBQUMsVUFBVXVLLFNBQVEsVUFBUSxPQUFLeEssS0FBS0MsS0FBSyxDQUFDVyxVQUFTNEosU0FBUSxVQUFRLFFBQU87SUFDbkcxSixRQUFRQyxHQUFHLENBQUM2SjtJQUNaOUosUUFBUUMsR0FBRyxDQUFDOEo7SUFDWi9KLFFBQVFDLEdBQUcsQ0FBRTZKLE9BQU8sTUFBS0M7SUFFekIsTUFBTUMsVUFBVUYsT0FBTyxNQUFLQyxNQUFNLDBEQUEwRDs7SUFFNUZ6TCx5REFBNEIsQ0FBQyxHQUFHMEw7SUFDOUIxTCxnREFBbUIsR0FBRyxJQUFJO0FBQzVCLEVBQUU7QUFJRixnQkFBZ0I7QUFDVCxNQUFNNkwsaUJBQWlCLFVBQVk7SUFDeEMsTUFBTTdMLHVDQUFVO0lBQ2hCLHlIQUF5SDtJQUN6SCxNQUFNOEwsU0FBbUI7UUFBQztRQUFLO1FBQUs7UUFBTTtRQUFLO0tBQUk7SUFDbkQsTUFBTUMsYUFBdUI7UUFDM0I7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxNQUFNQyxTQUFTLElBQUloTSx5Q0FBWSxHQUFHdUUsYUFBYTtJQUMvQyxNQUFNMEgsU0FBUyxJQUFJak0seUNBQVksR0FBR3VFLGFBQWE7SUFFL0MsZ0NBQWdDO0lBQ2hDOztvQkFFa0IsR0FFbEIsTUFBTXVELE1BQU0sSUFBSTlILDBDQUFhLENBQzNCLENBQUM4SSxNQUFNQyxPQUFTO1FBQ2RpRCxPQUFPdkYsb0JBQW9CLENBQUNzQyxNQUFNLEtBQUtEO0lBQ3ZDLHNDQUFzQztJQUN4QyxHQUNBO1FBQ0VpRCxVQUFVLENBQUNuTCxLQUFLUSxLQUFLLENBQUMwSyxNQUFNLENBQUMsRUFBRSxFQUFFO1FBQ2pDO1lBQUNDLFVBQVUsQ0FBQyxFQUFFO1lBQUVBLFVBQVUsQ0FBQyxFQUFFO1lBQUVBLFVBQVUsQ0FBQyxFQUFFO1NBQUM7UUFDN0NBLFVBQVUsQ0FBQ25MLEtBQUtRLEtBQUssQ0FBQzBLLE1BQU0sQ0FBQyxFQUFFLEVBQUU7UUFDakM7WUFBQ0MsVUFBVSxDQUFDLEVBQUU7WUFBRUEsVUFBVSxDQUFDLEVBQUU7U0FBQztLQUMvQixFQUNEekYsS0FBSyxDQUFDO0lBRVIsK0RBQStEO0lBQy9ELE1BQU02RixRQUFRLElBQUluTSxzQ0FBUyxDQUFDLENBQUM4SSxPQUFTO1FBQ3BDbUQsT0FBT3hGLG9CQUFvQixDQUFDLE1BQU0sTUFBTXFDO0lBQzFDLEdBQUcsTUFBTXhDLEtBQUssQ0FBQztJQUNmLGlEQUFpRDtJQUNqRHRHLHFEQUF3QixHQUFHO0lBQzNCQSxpREFBb0I7SUFDcEIsbURBQW1EO0lBRW5ELHVDQUF1QztJQUN2Q0Esb0RBQXVCLENBQUMsQ0FBQzhJLE9BQVM7UUFDaEMsdUJBQXVCO1FBRXZCcEgsUUFBUUMsR0FBRyxDQUFDO1FBRVptRyxJQUFJdUUsSUFBSTtRQUNSLCtCQUErQjtRQUMvQkosT0FBTzFHLEdBQUcsQ0FBQztZQUNUQyxhQUFhO1lBQ2JFLFVBQVU7Z0JBQ1JDLFFBQVE7Z0JBQ1IyRyxTQUFTO1lBQ1g7UUFDRjtJQUNBLDJFQUEyRTtJQUM3RSxHQUFHO0lBRUgsdUNBQXVDO0lBQ3ZDdE0sb0RBQXVCLENBQUMsQ0FBQzhJLE9BQVM7UUFDaEMsdUJBQXVCO1FBQ3ZCLG9CQUFvQjtRQUNwQnBILFFBQVFDLEdBQUcsQ0FBQztRQUNaLHVCQUF1QjtRQUN2Qm1HLElBQUl4QixLQUFLO1FBQ1QsK0JBQStCO1FBQy9CMkYsT0FBT3pHLFdBQVcsQ0FBQytHLE1BQU0sQ0FBQyxJQUFJO0lBQzlCLGdDQUFnQztJQUNsQyxHQUFHO0FBQ0wsRUFBRTtBQUVGLGdCQUFnQjtBQUNULE1BQU1DLGtCQUFrQixVQUFZO0lBQ3pDLE1BQU14TSx1Q0FBVTtJQUVoQixnRUFBZ0U7SUFDaEUsTUFBTTZFLFFBQVEsSUFBSTdFLDJDQUFjLENBQUNBLHVDQUFVLEVBQUV1RSxhQUFhO0lBQzFELE1BQU1xQyxNQUFNNUcscUNBQVE7SUFDcEI2RSxNQUFNOEgsYUFBYSxDQUFDLE1BQU0vRjtJQUMxQi9CLE1BQU04SCxhQUFhLENBQUMsTUFBTS9GLE1BQU07SUFDaEMvQixNQUFNOEgsYUFBYSxDQUFDLE1BQU0vRixNQUFNO0lBQ2hDL0IsTUFBTThILGFBQWEsQ0FBQyxNQUFNL0YsTUFBTTtJQUNoQy9CLE1BQU04SCxhQUFhLENBQUMsTUFBTS9GLE1BQU07SUFDaEMvQixNQUFNK0gsY0FBYyxDQUFDO1FBQUM7UUFBTTtRQUFNO1FBQU07UUFBTTtLQUFLLEVBQUVoRyxNQUFNO0FBQzdELEVBQUU7QUFFRixZQUFZO0FBQ0wsTUFBTWlHLGNBQWMsVUFBWTtJQUNyQyxNQUFNN00sdUNBQVU7SUFFaEIsTUFBTThNLFNBQVMsSUFBSTlNLHdDQUFXLENBQzVCLHFEQUNBdUUsYUFBYTtJQUNmdkUsd0NBQVcsR0FBR2lOLElBQUksQ0FBQyxJQUFNO1FBQ3ZCSCxPQUFPeEcsS0FBSztJQUNkO0FBQ0YsRUFBRTtBQUVGLFlBQVk7QUFDTCxNQUFNNEcsY0FBYyxVQUFZO0lBQ3JDLE1BQU1sTix1Q0FBVTtJQUVoQixNQUFNbU4sVUFBVSxJQUFJbk4seUNBQVksQ0FBQztRQUMvQnFOLE1BQU07WUFDSkMsSUFBSTtZQUNKLE9BQU87WUFDUCxPQUFPO1lBQ1BDLElBQUk7UUFDTjtRQUNBQyxTQUFTO0lBQ1gsR0FBR2pKLGFBQWE7SUFFaEJ2RSx3Q0FBVyxHQUFHaU4sSUFBSSxDQUFDLElBQU07UUFDdkJFLFFBQVExRyxvQkFBb0IsQ0FBQztZQUFDO1lBQU87WUFBTTtTQUFNLEVBQUU7SUFDckQ7QUFDRixFQUFFO0FBRUYsV0FBVztBQUNKLE1BQU1nSCxlQUFlLFVBQVk7SUFDdEMsTUFBTXpOLHVDQUFVO0lBRWhCLE1BQU04TSxTQUFTLElBQUk5TSx3Q0FBVyxDQUFDO1FBQzdCME4sS0FBSztRQUNMOUIsTUFBTSxLQUFLO1FBQ1grQixXQUFXLElBQUk7SUFDakI7SUFDQSw0QkFBNEI7SUFDNUIsTUFBTUMsYUFBYSxJQUFJNU4sNENBQWUsQ0FBQyxLQUFLdUUsYUFBYTtJQUN6RCxvQ0FBb0M7SUFDcEN1SSxPQUFPNUcsT0FBTyxDQUFDMEg7QUFDakIsRUFBRTtBQUVGLFlBQVk7QUFDTCxNQUFNRSxhQUFhLFVBQVk7SUFDcEMsTUFBTTlOLHVDQUFVO0lBRWhCLE1BQU0rTixNQUFNLElBQUkvTiw0Q0FBZSxHQUFHdUUsYUFBYTtJQUMvQyxnQkFBZ0I7SUFDaEJ3SixJQUFJRSxTQUFTLENBQUMzTixLQUFLLEdBQUc7SUFDdEIsOEJBQThCO0lBQzlCeU4sSUFBSUUsU0FBUyxDQUFDMUIsTUFBTSxDQUFDLE1BQU07QUFDN0IsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9mcm9udGVuZC9wbGF5Z3JvdW5kL1NvdW5kLnRzP2Y5NzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFuVHdvVG9uZSwgU2VnbWVudCB9IGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwnO1xuaW1wb3J0ICogYXMgVG9uZSBmcm9tICd0b25lJztcbmltcG9ydCAqIGFzIFZpc3VhbHMgZnJvbSAnLi9WaXN1YWxzJztcbmltcG9ydCB7IEVudmVsb3BlIH0gZnJvbSAndG9uZSc7XG5pbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi9kYXRhL0NHTWRhdGExJzsgLy9oZXJlIGlzIHdoZXJlIEkgY2FuIGxvYWQgZGlmZmVyZW50IGRhdGEgc2V0c1xuaW1wb3J0IF8sIHsgbm93IH0gZnJvbSAnbG9kYXNoJzsgXG5cbi8vQkcgYXJyYXkgLSB0aGlzIHdvcmtzLCBidXQgdGhlcmUgbWlnaHQgYmUgYSBtb3JlIGVsZWdhbnQgd2F5LCBhbmQgSSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGFjdHVhbGx5IHJlbW92ZSB0aGUgbnVsbCB2YWx1ZXMgb3Igbm90XG4vL2Zyb20gTHVjaWFubzogY29uc3QgZ2x1Y29zZVZhbHVlcyA9IGRhdGEuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuZ2x1Y29zZSAhPT0gbnVsbClcbmxldCBnbHVjb3NlVmFsdWVzID0gZGF0YS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5nbHVjb3NlID4gMCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUuZ2x1Y29zZSk7XG5nbHVjb3NlVmFsdWVzID0gZ2x1Y29zZVZhbHVlcy5maWx0ZXIoTnVtYmVyKTtcbi8vIGdsdWNvc2VWYWx1ZXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbi8vICAgY29uc29sZS5sb2coaXRlbSwgaW5kZXgpO1xuLy8gfSk7XG4vLyBjb25zb2xlLmxvZyhnbHVjb3NlVmFsdWVzLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKT0+cHJldmlvdXNWYWx1ZSArIGN1cnJlbnRWYWx1ZSwgMCkpO1xubGV0IG1pZEdsdWNvc2UgPSBnbHVjb3NlVmFsdWVzLmF0KE1hdGguZmxvb3IoZ2x1Y29zZVZhbHVlcy5sZW5ndGgvMikpO1xuXG4vL0B0cy1pZ25vcmVcbi8vIGxldCBhdmdHbHVjb3NlID0gKChnbHVjb3NlVmFsdWVzLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSA9PiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlLCAwKSkvZ2x1Y29zZVZhbHVlcy5sZW5ndGgpO1xubGV0IGF2Z0dsdWNvc2UgPSAoKGdsdWNvc2VWYWx1ZXMucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IChwcmV2aW91c1ZhbHVlID8/IDApICsgKGN1cnJlbnRWYWx1ZSA/PyAwKSwgMCkgPz8gMSkvZ2x1Y29zZVZhbHVlcy5sZW5ndGgpXG5cbi8vQHRzLWlnbm9yZVxubGV0IGNhbGNNb2RlID0gKE1hdGgucm91bmQobWlkR2x1Y29zZSUxKjEwKSArIE1hdGguZmxvb3IobWlkR2x1Y29zZSkpJTc7XG5sZXQgY2FsY0tleSA9IChNYXRoLnJvdW5kKGF2Z0dsdWNvc2UlMSoxMCkgKyBNYXRoLmZsb29yKGF2Z0dsdWNvc2UpKSUxMjtcbmxldCBicG1JbmRleCA9IDA7XG5sZXQgYnBtUmFuZ2UgPSBbMTIwLCAyMjBdXG5cbi8vQHRzLWlnbm9yZVxubGV0IGNhbGNCUE0gPSBjb252ZXJ0UmFuZ2UoKE1hdGgucm91bmQoZ2x1Y29zZVZhbHVlcy5hdChicG1JbmRleCklMSoxMCkrTWF0aC5mbG9vcihnbHVjb3NlVmFsdWVzLmF0KGJwbUluZGV4KSkpJTIwLFswLCAyMF0sIGJwbVJhbmdlKTtcbmNvbnNvbGUubG9nKFwiTW9kZSAjID0gXCIgKyBjYWxjTW9kZSk7XG5jb25zb2xlLmxvZyhcIktleSAjID0gXCIgKyBjYWxjS2V5KTtcbmNvbnNvbGUubG9nKFwiQlBNID0gXCIgKyBjYWxjQlBNKTtcblxuLy9jcmVhdGUgYSByZW9yZGVyZWQgYXJyYXkgZm9yIENHTSBkYXRhIHBsYXliYWNrLCBpbnRlcnNwZXJzZXMgZ3JvdXBzIG9mIDNcbmxldCBpbnRlckJHQXJyYXkgPSBbXTtcbmxldCBpbnRlckp1bXAgPSBNYXRoLmZsb29yKGdsdWNvc2VWYWx1ZXMubGVuZ3RoLzMpO1xubGV0IHBhcnRBcnJheTEgPSBnbHVjb3NlVmFsdWVzLnNsaWNlKDAsIGludGVySnVtcCk7XG5sZXQgcGFydEFycmF5MiA9IGdsdWNvc2VWYWx1ZXMuc2xpY2UoaW50ZXJKdW1wLCBpbnRlckp1bXAqMik7XG5sZXQgcGFydEFycmF5MyA9IGdsdWNvc2VWYWx1ZXMuc2xpY2UoaW50ZXJKdW1wKjIpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlckp1bXA7IGkrKyl7XG4gIGludGVyQkdBcnJheS5wdXNoKHBhcnRBcnJheTFbaV0sIHBhcnRBcnJheTJbaV0sIHBhcnRBcnJheTNbaV0pO1xuICB9XG4gIGNvbnNvbGUubG9nKFwiSU5URVIgPVwiLCBpbnRlckJHQXJyYXkpO1xuICBjb25zb2xlLmxvZyhcIkJHID0gXCIsIGdsdWNvc2VWYWx1ZXMpXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGNyZWF0ZSBuZXcgYXJyYXlzIHdpdGggdmFsdWVzIHRvIGZlZWQgaW50byB2aXN1YWxzIGFuZCBzb3VuZHMgdGhyb3VnaCBzY2FsaW5nL2xpbmVhciBpbnRlcnBvbGF0aW9uXG4vL2Zyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0MjI0NTM1L3NjYWxpbmctYmV0d2Vlbi10d28tbnVtYmVyLXJhbmdlc1xuZnVuY3Rpb24gY29udmVydFJhbmdlKHZhbHVlLCByMSwgcjIpIHtcbiAgcmV0dXJuICh2YWx1ZSAtIHIxWzBdKSAqIChyMlsxXSAtIHIyWzBdKSAvIChyMVsxXSAtIHIxWzBdKSArIHIyWzBdO1xufVxuY29uc3QgbWF4QkcgPSBNYXRoLm1heCguLi5nbHVjb3NlVmFsdWVzKVxuY29uc3QgbWluQkcgPSBNYXRoLm1pbiguLi5nbHVjb3NlVmFsdWVzKVxuXG4vL2FycmF5cyBmb3IgdXNlIHdpdGggdmlzdWFscyBhbmQgYXVkaW8gKG5vdCBkZWRpY2F0ZWQsIHVzZSBhcyBhcHByb3ByaWF0ZSlcbmNvbnN0IGJnUmFuZ2UwMSA9IGdsdWNvc2VWYWx1ZXMubWFwKChudW0pID0+IGNvbnZlcnRSYW5nZShudW0sIFttaW5CRywgbWF4QkddLFswLDFdKSlcbmNvbnN0IGJnUmFuZ2U5ID0gZ2x1Y29zZVZhbHVlcy5tYXAoKG51bSkgPT4gY29udmVydFJhbmdlKG51bSwgW21pbkJHLCBtYXhCR10sWzAsOV0pKVxuY29uc3QgYmdSYW5nZTMxMCA9IGdsdWNvc2VWYWx1ZXMubWFwKChudW0pID0+IGNvbnZlcnRSYW5nZShudW0sIFttaW5CRywgbWF4QkddLFswLjAwMDEsMC4wMV0pKVxuY29uc3QgYmdSYW5nZTEwMCA9IGdsdWNvc2VWYWx1ZXMubWFwKChudW0pID0+IGNvbnZlcnRSYW5nZShudW0sIFttaW5CRywgbWF4QkddLFswLjAxLDAuMV0pKVxuY29uc3QgYmdSYW5nZTMwMCA9IGdsdWNvc2VWYWx1ZXMubWFwKChudW0pID0+IGNvbnZlcnRSYW5nZShudW0sIFttaW5CRywgbWF4QkddLFswLjAwMDEsMC4xXSkpXG5cblxuLy9TQ0FMRV9NQUtJTkcgKHdpdGggaGVscCBmcm9tIGh0dHBzOi8vd3d3Lmd1aXRhcmxhbmQuY29tL011c2ljVGhlb3J5V2l0aFRvbmVKUy9QbGF5TW9kZXMuaHRtbClcbmNvbnN0IG1ham9yRm9ybXVsYSA9IFswLDIsNCw1LDcsOSwxMV07XG5jb25zdCBtb2RlTmFtZXMgPSBbJ21ham9yJywnZG9yaWFuJywncGhyeWdpYW4nLCdseWRpYW4nLCdtaXhvbHlkaWFuJywnYWVvbGlhbicsJ2xvY3JpYW4nXVxuY29uc3QgbXlNb2RlTnVtID0gY2FsY01vZGU7XG5jb25zdCBteUtleSA9IGNhbGNLZXk7XG5jb25zdCBteU1vZGVGb3JtdWxhID0gbWFrZU1vZGVGb3JtdWxhKG1ham9yRm9ybXVsYSwgbXlNb2RlTnVtLCBteUtleSwgMTEpO1xuXG4vL3BhcmVudFNjYWxlRm9ybXVsYSBpcyBpbnRlcnZhbCBzcGFjaW5ncyB0byBiZSByZXBlYXRlZCAoZXguIG1ham9yRm9ybXVsYSksIG1vZGVOdW0gcGlja3Mgd2hpY2ggaW50ZXJ2YWwgdG8gdXNlIGFzIHJvb3QgKGhlbmNlIHNlbGVjdHMgbW9kZSksIHJvb3QgaXMgcGl0Y2ggY2xhc3MgKGkuZSBrZXkpIGJhc2UgTUlESSBub3RlIGZyb20gMC0xMSwgZm9ybXVsYUxlbmd0aCBhbGxvd3MgZm9yIGNyZWF0aW5nIGxvbmdlciBhbmQgc2hvcnRlciByZXBldGl0aW9ucyBvZiB0aGUgaW50ZXJ2YWwgc3BhY2luZ3NcbmZ1bmN0aW9uIG1ha2VNb2RlRm9ybXVsYShwYXJlbnRTY2FsZUZvcm11bGEsIG1vZGVOdW0sIHJvb3QgPSAwLCBmb3JtdWxhTGVuZ3RoPTksKSB7XG4gIGxldCBzY2FsZUluZGV4ID0gMDtcbiAgbGV0IG1vZGVGb3JtdWxhID0gW107XG4gIGxldCBtb2RlSW50ZXJ2YWw7XG4gIGZvcihsZXQgaT0wOyBpPHBhcmVudFNjYWxlRm9ybXVsYS5sZW5ndGgqZm9ybXVsYUxlbmd0aDsgaSsrKSB7XG4gICAgc2NhbGVJbmRleCA9IChpK21vZGVOdW0pICUgcGFyZW50U2NhbGVGb3JtdWxhLmxlbmd0aDtcbiAgICBtb2RlSW50ZXJ2YWwgPSAocGFyZW50U2NhbGVGb3JtdWxhW3NjYWxlSW5kZXhdIC0gcGFyZW50U2NhbGVGb3JtdWxhW21vZGVOdW1dICsxMikgJSAxMjtcbiAgIG1vZGVJbnRlcnZhbCA9IG1vZGVJbnRlcnZhbCArIHJvb3QgKyBNYXRoLmZsb29yKGkvcGFyZW50U2NhbGVGb3JtdWxhLmxlbmd0aCkqMTI7XG4gICAgbW9kZUZvcm11bGEucHVzaChtb2RlSW50ZXJ2YWwpO1xuICAgIFxuICB9ICBcbiAgY29uc29sZS5sb2coXCJtb2RlPVwiK21vZGVOYW1lc1ttb2RlTnVtXStcIiBmb3JtdWxhPVwiK21vZGVGb3JtdWxhLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gbW9kZUZvcm11bGE7XG59XG5cbi8vbW9kZUZvcm11bGEgPSB0aGUgcmVzdWx0IG9mIHRoZSBtb2RlTWFrZUZvcm11bGFcbi8vdXBwZXJMaW1pdCA9IGhvdyBtYW55IHNjYWxlRGVncmVlcyBhbmQgaGVuY2UgaW50ZXJ2YWxzIHRvIHNwcmVhZCB0aGUgbm90ZXMgb3V0IG92ZXIsIG15IHJlY29tbWVuZGVkIGFwcHJvYWNoIGlzIHRvIHRha2UgdGhlIGxlbmd0aCBvZiB0aGUgbWFqb3JGb3JtdWxhIChvciB3aGF0ZXZlciBiYXNlIGludGVydmFsIGZvcm11bGEgYmVpbmcgdXNlZCkgYW5kIG11bHRpcGx5IGJ5IHRoZSBkZXNpcmVkIG51bWJlciBvZiBvY3RhdmVzIHRvIHNwcmVhZCBvdXQgb3Zlci5cbi8vYmFzZU9jdGF2ZSA9IHdoYXQgb2N0YXZlIHRvIHN0YXJ0IGF0XG5mdW5jdGlvbiBjb252ZXJ0Qkd0b05vdGVzKG1vZGVGb3JtdWxhOiBudW1iZXJbXSwgdXBwZXJMaW1pdCwgYmFzZU9jdGF2ZT0yKSB7XG4gIGxldCBiZ1NjYWxlRGVncztcbiAgbGV0IGJnSW50ZXJ2YWxzO1xuICBiZ1NjYWxlRGVncyA9IGdsdWNvc2VWYWx1ZXMubWFwKChudW0pID0+IE1hdGgucm91bmQoY29udmVydFJhbmdlKG51bSwgW21pbkJHLCBtYXhCR10sWzAsIHVwcGVyTGltaXQtMV0pKSk7XG4gIGJnSW50ZXJ2YWxzID0gYmdTY2FsZURlZ3MubWFwKChudW0pPT5tb2RlRm9ybXVsYVtudW1dK2Jhc2VPY3RhdmUqMTIpO1xuICByZXR1cm4gYmdJbnRlcnZhbHM7XG4gIH1cblxuICBcblxuLy9jcmVhdGUgYSBzeW50aCBhbmQgY29ubmVjdCBpdCB0byB0aGUgbWFpbiBvdXRwdXQgKHlvdXIgc3BlYWtlcnMpXG5jb25zdCByZXZlcmJBID0gbmV3IFRvbmUuUmV2ZXJiKDUpO1xuXG5jb25zdCBwYW5Wb2xTMSA9IG5ldyBUb25lLlBhblZvbCgtMC43LCAwKS50b0Rlc3RpbmF0aW9uKCk7XG5jb25zdCBwYW5Wb2xTMiA9IG5ldyBUb25lLlBhblZvbCgwLjcsIDApLnRvRGVzdGluYXRpb24oKTtcbmNvbnN0IHBhblZvbFMzID0gbmV3IFRvbmUuUGFuVm9sKDAsIDApLnRvRGVzdGluYXRpb24oKTtcbmNvbnN0IHBhblZvbEsxID0gbmV3IFRvbmUuUGFuVm9sKDAsIC02KS50b0Rlc3RpbmF0aW9uKCk7XG5cbmNvbnN0IGtpY2tTeW50aCA9IG5ldyBUb25lLk1lbWJyYW5lU3ludGgoKTtcblxuY29uc3Qgc3ludGggPSBuZXcgVG9uZS5QbHVja1N5bnRoKCk7XG5jb25zdCBzeW50aDIgPSBuZXcgVG9uZS5QbHVja1N5bnRoKCk7XG5jb25zdCBzeW50aDMgPSBuZXcgVG9uZS5QbHVja1N5bnRoKCk7XG5cbmNvbnN0IGZtU3ludGggPSBuZXcgVG9uZS5GTVN5bnRoKCk7XG5jb25zdCBmbVN5bnRoMiA9IG5ldyBUb25lLkZNU3ludGgoKTtcbmNvbnN0IGZtU3ludGgzID0gbmV3IFRvbmUuRk1TeW50aCgpO1xuXG5jb25zdCBmbU1JT2Zmc2V0ID0gNTA7XG5cbmNvbnN0IGZtU3dlbGwgPSBuZXcgVG9uZS5GTVN5bnRoKCk7XG5mbVN3ZWxsLnNldCh7XG4gIGhhcm1vbmljaXR5OiAwLjUsXG4gIG1vZHVsYXRpb25JbmRleDogNSxcbiAgZW52ZWxvcGU6IHthdHRhY2s6IDAuMDF9LFxuICBtb2R1bGF0aW9uRW52ZWxvcGU6IHthdHRhY2s6IDAuMSxcbiAgZGVjYXk6IDEuNSxcbiAgc3VzdGFpbjogMC4xfSxcbiAgbW9kdWxhdGlvbjoge3R5cGU6IFwidHJpYW5nbGU4XCJ9LFxuICBvc2NpbGxhdG9yOiB7dHlwZTogXCJ0cmlhbmdsZTEzXCJ9XG4gIFxuICB9KVxuXG5zeW50aC5jb25uZWN0KHBhblZvbFMxKTtcbnN5bnRoLmNoYWluKHJldmVyYkEsIFRvbmUuRGVzdGluYXRpb24pO1xuc3ludGgyLmNvbm5lY3QocGFuVm9sUzIpO1xuc3ludGgyLmNoYWluKHJldmVyYkEsIFRvbmUuRGVzdGluYXRpb24pO1xuc3ludGgzLmNvbm5lY3QocGFuVm9sUzMpO1xuc3ludGgzLmNoYWluKHJldmVyYkEsIFRvbmUuRGVzdGluYXRpb24pO1xuXG5mbVN5bnRoLmNvbm5lY3QocGFuVm9sUzEpO1xuZm1TeW50aC5jaGFpbihyZXZlcmJBLCBUb25lLkRlc3RpbmF0aW9uKTtcbmZtU3ludGgyLmNvbm5lY3QocGFuVm9sUzIpO1xuZm1TeW50aDIuY2hhaW4ocmV2ZXJiQSwgVG9uZS5EZXN0aW5hdGlvbik7XG5mbVN5bnRoMy5jb25uZWN0KHBhblZvbFMzKTtcbmZtU3ludGgzLmNoYWluKHJldmVyYkEsIFRvbmUuRGVzdGluYXRpb24pO1xuXG5mbVN3ZWxsLmNvbm5lY3QocGFuVm9sUzEpO1xuZm1Td2VsbC5jaGFpbihyZXZlcmJBLCBUb25lLkRlc3RpbmF0aW9uKTtcblxua2lja1N5bnRoLmNvbm5lY3QocGFuVm9sSzEpO1xuXG5cblxuLy8gKiBzaW1wbGVcbmV4cG9ydCBjb25zdCBwbGF5U2ltcGxlID0gYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBUb25lLnN0YXJ0KCk7XG4gIC8vZGVidWdnaW5nOlxuICBjb25zb2xlLmxvZyhnbHVjb3NlVmFsdWVzLm1hcCh4PT4geCAqIDEwKSk7XG4gIC8vY29uc29sZS5sb2coVG9uZSk7XG4gIC8vcGxheSBhIG1pZGRsZSAnQycgZm9yIHRoZSBkdXJhdGlvbiBvZiBhbiA4dGggbm90ZVxuICBWaXN1YWxzLnN0YXJ0KCk7XG4gIC8vVmlzdWFscy5meDQoZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5yYW5kb20oKSoxMH0pO1xuIC8vIFZpc3VhbHMuZngzKDIwLCAwLjUpXG5WaXN1YWxzLmZ4NShnbHVjb3NlVmFsdWVzLm1hcCh4PT4geCAqIDEwKSwgZ2x1Y29zZVZhbHVlcywgMC42LCAwLjUpO1xuICBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZSgnQzMnLCAnOG4nKTtcbi8vdGhpcyB3b3Jrc1xuIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbntcbiAgbGV0IGJnID0gZGF0YVtpXS5nbHVjb3NlO1xuICBpZiAoYmcgPj0gOC4wKXtcbiAgICBjb25zb2xlLmxvZyhcImhpZ2ggXCIsIGksIGRhdGFbaV0uZ2x1Y29zZSlcbiAgICAvL2RvIHNvbWV0aGluZyBoZXJlXG4gIH0gZWxzZVxuICBpZiAoYmc8PSA3LjkgJiYgYmc+PTQuMCApe1xuICAgIGNvbnNvbGUubG9nKFwidGFyZ2V0IFwiLCBpLCBkYXRhW2ldLmdsdWNvc2UpXG4gICAgLy9kbyBzb21ldGhpbmcgaGVyZVxuICB9IGVsc2VcbiAgaWYgKGJnIDwgNC4wKXtcbiAgICBjb25zb2xlLmxvZyhcImxvdyBcIiwgaSwgZGF0YVtpXS5nbHVjb3NlKVxuICAgIC8vZG8gc29tZXRoaW5nIGhlcmVcbiAgfVxufVxuXG5cblxufTtcblxuLy8gKiBzaW1wbGUgZG91YmxlXG5leHBvcnQgY29uc3QgcGxheVRpbWVDb250cm9sID0gYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBUb25lLnN0YXJ0KCk7XG4gIGNvbnN0IG5vdyA9IFRvbmUubm93KCk7XG4gIC8vIHRyaWdnZXIgdGhlIGF0dGFjayBpbW1lZGlhdGVseVxuICAvLyFzeW50aC50cmlnZ2VyQXR0YWNrKCdDNCcsIG5vdyk7XG4gIC8vIHdhaXQgb25lIHNlY29uZCBiZWZvcmUgdHJpZ2dlcmluZyB0aGUgcmVsZWFzZVxuICAvLyEgc3ludGgudHJpZ2dlclJlbGVhc2Uobm93ICsgMyk7XG4gIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKCdHMicsICcxbicsIG5vdyArIDEsIDEpO1xufTtcblxuLy8gKiBTZXF1ZW5jZVxuXG5leHBvcnQgY29uc3QgcGxheVNxdWVuY2UgPSBhc3luYyAoKSA9PiB7XG4gIGF3YWl0IFRvbmUuc3RhcnQoKTtcbiAgXG4vL0ZGVCBhbmFseXplcyB0aGUgYXVkaW8gb3V0cHV0LCBjYW4gdXNlIHRoZSBudW1iZXJzIGl0IHJldHVybnMgdG8gZG8gc3R1ZmYgdG8gdGhlIHZpc3VhbHNcbiAgY29uc3QgZmZ0ID0gbmV3IFRvbmUuRkZUKDE2KTsgXG5mbVN3ZWxsLmNvbm5lY3QoZmZ0KTtcbmZmdC5zZXQoe1xuICBub3JtYWxSYW5nZTogdHJ1ZSxcbiAgc21vb3RoaW5nOiAwLjggXG59KVxuIGxldCBjb3VudGVyUzFWZWwgPSAwO1xuIGxldCBjb3VudGVyUzJWZWwgPSAwO1xuIGxldCBjb3VudGVyUzNWZWwgPSAwO1xuIGNvbnN0IGJnTUlESSA9IGNvbnZlcnRCR3RvTm90ZXMobXlNb2RlRm9ybXVsYSwgbWFqb3JGb3JtdWxhLmxlbmd0aCozLCA0KTtcbiBjb25zdCBiZ0ZyZXFzID0gYmdNSURJLm1hcCgobnVtKT0+VG9uZS5tdG9mKG51bSkpO1xuIGNvbnNvbGUubG9nKGJnRnJlcXMpO1xuIFZpc3VhbHMuc3RhcnQoKTtcbiAvL1Zpc3VhbHMuZng1KGdsdWNvc2VWYWx1ZXMubWFwKHg9PiB4ICogMTApLCBnbHVjb3NlVmFsdWVzLCAwLjYsIDAuNSk7XG4gLy9WaXN1YWxzLmZ4MygyLCAwLjYpXG4gVmlzdWFscy5meDgoYmdSYW5nZTAxLCBmZnROb3JtKTtcbiAvL1Zpc3VhbHMuZng4dCgpO1xuIC8vVmlzdWFscy5meDhzaW1wbGUoKTtcbiAvL1Zpc3VhbHMuZng5ZWFzZSgpO1xuIC8vYmdWaXNFdmVudChub3cpO1xuXG4gIC8vayBpcyAjIG9mIHB1bHNlcywgbiBpcyAjIG9mIHNsb3RzLCBjIGlzIG5vdGVuYW1lIGFzIFN0cmluZyAoZXguIFwiQzNcIik7IHRoaXMgaXMgZm9yIGNyZWF0aW5nIHJoeXRobXMgZnJvbSB0aGUgZGF0YVxuICBmdW5jdGlvbiBiam9ya2x1bmQoaywgbiwgYykge1xuICAgIC8vcmV0dXJucyBrIHB1bHNlcyAoMXMpIGZvbGxvd2VkIGJ5IG4tayByZXN0cyAoMHMpXG4gICAgbGV0IHNlcSA9IF8udGltZXMoaywgXy5jb25zdGFudChbMV0pKS5jb25jYXQoXy50aW1lcyhuIC0gaywgXy5jb25zdGFudChbMF0pKSk7XG4gICAgLy9jb25zb2xlLmxvZyhfLnRpbWVzKGssIF8uY29uc3RhbnQoWzFdKSkuY29uY2F0KF8udGltZXMobiAtIGssIF8uY29uc3RhbnQoWzBdKSkpKVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvL3NldHMgdHdvIHZhcmlhYmxlcyB0byBwYXJ0aXRpb24gdGhlIHZhbHVlcyBpbiB0aGUgc2VxXG4gICAgICBsZXQgW2hlYWQsIHJlbWFpbmRlcl0gPSBfLnBhcnRpdGlvbihzZXEsIGkgPT4gXy5pc0VxdWFsKGksIHNlcVswXSkpO1xuICAgICAgLy9jb25zb2xlLmxvZyhoZWFkLCByZW1haW5kZXIsIHNlcSk7XG4gICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCA8IDIpIGJyZWFrO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihoZWFkLmxlbmd0aCwgcmVtYWluZGVyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICBzZXFbaV0gPSBzZXFbaV0uY29uY2F0KHNlcS5wb3AoKSk7XG4gICAgICB9XG4gICAgfVxuICAgcmV0dXJuIF8uZmxhdHRlbihzZXEpLm1hcChmdW5jdGlvbih2YWx1ZSl7aWYodmFsdWUgPT0gMSl7cmV0dXJuIGN9ZWxzZXtyZXR1cm4gbnVsbH19KVxuICB9O1xuXG5sZXQgbm90ZXMgPSBbXVxubGV0IG5vdGVzMiA9IFtdXG5sZXQgbm90ZXMzID0gW11cbmxldCBraWNrID0gW11cblxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBzZXF1ZW5jZSB3aXRoIHRoZSBzeW50aCBhbmQgbm90ZXNcbmNvbnN0IHN5bnRoUGFydCA9IG5ldyBUb25lLlNlcXVlbmNlKFxuICBmdW5jdGlvbih0aW1lLCBub3RlKSB7XG4gICAgZm1TeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShub3RlLCBcIjY0blwiLCB0aW1lLCBiZ1JhbmdlMDFbY291bnRlclMxVmVsJWJnUmFuZ2UwMS5sZW5ndGhdKTtcbiAgICBjb25zb2xlLmxvZyhcInN5bnRoUGFydDFcIik7XG4gICAgLy90aGlzIGlzIGEgd2F5IG9mIGluc2VydGluZyBvdGhlciB2YXJpYWJsZSBjaGFuZ2VzIG9uIGEgcGVyIG5vdGUgYmFzaXNcbiAgICAgIC8vbmVlZCB0byBkZWxldGUgdGhpcyBpZiB5b3Ugd2FudCBpdCB0byBoYXBwZW4gZXZlcnkgYmpvcmtsdW5kIHN3aXRjaCBpbnN0ZWFkIG9mIG5vdGUgc3dpdGNoXG4gICAvKiBmbVN5bnRoLnNldCh7XG4gICAgICBoYXJtb25pY2l0eTogMS41LFxuICAgICAgbW9kdWxhdGlvbkluZGV4OiA1LFxuICAgICAgZW52ZWxvcGU6IHthdHRhY2s6IDAuMDF9LFxuICAgICAgbW9kdWxhdGlvbkVudmVsb3BlOiB7YXR0YWNrOiAwLjEsXG4gICAgICBkZWNheTogMC4yNSxcbiAgICAgIHN1c3RhaW46IDAuMX0sXG4gICAgICBtb2R1bGF0aW9uOiB7dHlwZTogXCJzaW5lXCJ9LFxuICAgICAgb3NjaWxsYXRvcjoge3R5cGU6IFwic2luZVwifVxuICAgICAgfSkgKi9cbiAgICBjb3VudGVyUzFWZWwrKztcbiAgfSxcbiAgbm90ZXMsXG4gIFwiOG5cIlxuKTtcblxuLy8gY3JlYXRlIGEgbmV3IHNlcXVlbmNlIHdpdGggdGhlIHN5bnRoIGFuZCBub3Rlc1xuY29uc3Qgc3ludGhQYXJ0MiA9IG5ldyBUb25lLlNlcXVlbmNlKFxuICBmdW5jdGlvbih0aW1lLCBub3RlKSB7XG4gIGZtU3ludGgyLnRyaWdnZXJBdHRhY2tSZWxlYXNlKG5vdGUsIFwiNjRuXCIsIHRpbWUsIGJnUmFuZ2UwMVtjb3VudGVyUzJWZWwlYmdSYW5nZTAxLmxlbmd0aF0pO1xuICBjb25zb2xlLmxvZyhcInN5bnRoUGFydDJcIik7XG4gICAgY291bnRlclMyVmVsKys7XG4gIH0sXG4gIG5vdGVzMixcbiAgXCI4blwiXG4pO1xuXG4vLyBjcmVhdGUgYSBuZXcgc2VxdWVuY2Ugd2l0aCB0aGUgc3ludGggYW5kIG5vdGVzXG5jb25zdCBzeW50aFBhcnQzID0gbmV3IFRvbmUuU2VxdWVuY2UoXG4gIGZ1bmN0aW9uKHRpbWUsIG5vdGUpIHtcbiAgICBmbVN5bnRoMy50cmlnZ2VyQXR0YWNrUmVsZWFzZShub3RlLCBcIjY0blwiLCB0aW1lLCBiZ1JhbmdlMDFbY291bnRlclMzVmVsJWJnUmFuZ2UwMS5sZW5ndGhdKTtcbiAgICBjb25zb2xlLmxvZyhcInN5bnRoUGFydDNcIik7XG4gICAgY291bnRlclMzVmVsKys7XG4gIH0sXG4gIG5vdGVzMyxcbiAgXCI4blwiXG4pO1xuXG4vLyBjcmVhdGUgYSBuZXcgc2VxdWVuY2Ugd2l0aCB0aGUgc3ludGggYW5kIG5vdGVzXG5jb25zdCBraWNrUGFydCA9IG5ldyBUb25lLlNlcXVlbmNlKFxuICBmdW5jdGlvbih0aW1lLCBub3RlKSB7XG4gICAga2lja1N5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKG5vdGUsIFwiMTZuXCIsIHRpbWUpO1xuICB9LFxuICBraWNrLFxuICBcIjJuXCJcbik7XG5cbi8vIFNldHVwIHRoZSBzeW50aCB0byBiZSByZWFkeSB0byBwbGF5IG9uIGJlYXQgMVxuc3ludGhQYXJ0LnN0YXJ0KCk7XG5zeW50aFBhcnQyLnN0YXJ0KCk7XG5zeW50aFBhcnQzLnN0YXJ0KCk7XG5raWNrUGFydC5zdGFydCgpO1xuXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3MgYSB0aW1lIGludG8gdGhlIHN0YXJ0IG1ldGhvZCBcbi8vIHlvdSBjYW4gc3BlY2lmeSB3aGVuIHRoZSBzeW50aCBwYXJ0IHN0YXJ0cyBcbi8vIGUuZy4gLnN0YXJ0KCc4bicpIHdpbGwgc3RhcnQgYWZ0ZXIgMSBlaWdodGggbm90ZS8vIHN0YXJ0IHRoZSB0cmFuc3BvcnQgd2hpY2ggY29udHJvbHMgdGhlIG1haW4gdGltZWxpbmVcbi8vU2V0IHRoZSBCUE0gYW5kIHN0YXJ0IHRoZSB0cmFuc3BvcnRcblRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSA9IGNhbGNCUE07XG5Ub25lLlRyYW5zcG9ydC5zdGFydCgpO1xuXG4vL2Z1bmN0aW9uIGZvciBwdW5jdHVhbCBldmVudHMgdGhhdCB3aWxsIGhhcHBlbiBvbiB0b3Agb2YgdGhlIEV1Y2xpZGVhbiByaHl0aG1zIGNyZWF0ZWQgYnkgdGhlIEJqb3JrbHVuZCBmdW5jdGlvblxuZnVuY3Rpb24gc3dlbGxGTUV2ZW50MSAocywgZnJlcSwgYXRrLCBkdXIpIHtUb25lLlRyYW5zcG9ydC5zY2hlZHVsZSgodGltZSk9PntcbmZtU3dlbGwudHJpZ2dlckF0dGFja1JlbGVhc2UoZnJlcSwgZHVyKTtcbmZtU3dlbGwuc2V0KHtcbiAgaGFybW9uaWNpdHk6IDAuNSxcbiAgbW9kdWxhdGlvbkluZGV4OiA1LFxuICBlbnZlbG9wZToge2F0dGFjazogYXRrfSxcbiAgbW9kdWxhdGlvbkVudmVsb3BlOiB7YXR0YWNrOiBhdGssXG4gIGRlY2F5OiAxLjUsXG4gIHN1c3RhaW46IDAuMX0sXG4gIG1vZHVsYXRpb246IHt0eXBlOiBcInRyaWFuZ2xlOFwifSxcbiAgb3NjaWxsYXRvcjoge3R5cGU6IFwidHJpYW5nbGUxM1wifVxuICB9KTtcbn0sIHMpO31cblxuZnVuY3Rpb24gdGltYnJlU2hpZnQocywgc3ludGhOYW1lLCBoYXJtb24sIG1vZGluZGV4KSB7VG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoKHRpbWUpPT57XG4gIHN5bnRoTmFtZS5zZXQoe1xuICAgIGhhcm1vbmljaXR5OiBoYXJtb24sXG4gICAgbW9kdWxhdGlvbkluZGV4OiBtb2RpbmRleCxcbiAgICBlbnZlbG9wZToge2F0dGFjazogMC4wMDEsXG4gICAgICBkZWNheTogMC4wMDV9LFxuICAgICAgbW9kdWxhdGlvbkVudmVsb3BlOiB7YXR0YWNrOiAwLjAwMSxcbiAgICAgIGRlY2F5OiAwLjA1LFxuICAgICAgc3VzdGFpbjogMH0sXG4gICAgICBtb2R1bGF0aW9uOiB7dHlwZTogXCJzaW5lXCJ9LFxuICAgICAgb3NjaWxsYXRvcjoge3R5cGU6IFwic2luZVwifVxuICAgIH0pO1xuICB9LCBzKTt9XG5cbi8vZnVuY3Rpb24gZm9yIHNjaGVkdWxpbmcgY2hhbmdlcyBpbiB0aGUgQmpvcmtsdW5kIHJoeXRobSBvZiB0aGUgc3BlY2lmaWVkIHN5bnRoIHBhcnQgYW5kIGFueSBvdGhlciBjaGFuZ2UgdGhhdCB3b3VsZCBiZSBzeW5jaG9ybml6ZWQgd2l0aCB0aGVzZSBjaGFuZ2VzXG4vL3MgaXMgZm9yIHNoZWR1bGUgLSB0aGUgdGltZSBhdCB3aGljaCBpdCBoYXBwZW5zOyBuIGlzIHRoZSBCRyBudW1iZXJcbmZ1bmN0aW9uIGJnRXZlbnQgKHMsIG4sIGZyZXEpIHsgVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoKHRpbWUpID0+IHtcbiAgc3ludGhQYXJ0LmV2ZW50cyA9IGJqb3JrbHVuZChiZ1NwbGl0TWluKG4pLCBiZ1NwbGl0TWF4KG4pLCBmcmVxKVxuICBjb25zb2xlLmxvZyhzeW50aFBhcnQuZXZlbnRzKVxuICBjb25zb2xlLmxvZyhuKVxuICBUb25lLkRyYXcuc2NoZWR1bGUoKCkgPT4ge1xuXHRcdC8vIGRvIGRyYXdpbmcgb3IgRE9NIG1hbmlwdWxhdGlvbiBoZXJlXG4gICAvLyBWaXN1YWxzLmZ4MygvKmZ1bmN0aW9uKCl7bGV0IHkgPSAgZmZ0LmdldFZhbHVlKCk7IHJldHVybiB5WzFdKjEwMDAgKyAxfSovcywgZnVuY3Rpb24oKXtsZXQgeSA9ICBmZnQuZ2V0VmFsdWUoKTsgcmV0dXJuIHlbMF0qMTB9KTtcblx0Ly9WaXN1YWxzLmZ4NShuLCBuLCBmZnROb3JtLCBuKjAuMDUpXHRcbiAgIC8vY29uc29sZS5sb2codGltZSk7XG5cdH0sIHRpbWUpO1xufSwgcyk7fVxuXG4vL2xpdHRsZSBmdW5jdGlvbiB0byBnZXQgZmZ0IGRhdGEgdmFsdWVzIHJvdWdobHkgYmV0d2VlbiAwIGFuZCAxIC0gY2FuIGNoYW5nZSBtdWx0aXBsaWVyIGZvciBkaWZmZXJlbnQgcmFuZ2VzIGV0Yy5cbi8vUS0gaG93IGNhbiB5b3VyIHBlcmZvcm0gYW4gb3BlcmF0aW9uIChtdWx0aXBseSkgb24gdGhlIHZhbHVlIHJldHVybmVkIGZyb20gYSBmdW5jdGlvbj9cbmZ1bmN0aW9uIGZmdE5vcm0gKCl7bGV0IHkgPSAgZmZ0LmdldFZhbHVlKCk7IHJldHVybiB5WzBdKjEwfVxuXG4vL2Z1bmN0aW9uIGZvciBzY2hlZHVsaW5nIGNoYW5nZXMgaW4gdGhlIEJqb3JrbHVuZCByaHl0aG0gb2YgdGhlIHNwZWNpZmllZCBzeW50aCBwYXJ0IGFuZCBhbnkgb3RoZXIgY2hhbmdlIHRoYXQgd291bGQgYmUgc3luY2hvcm5pemVkIHdpdGggdGhlc2UgY2hhbmdlc1xuZnVuY3Rpb24gYmdFdmVudDIgKHMsIG4sIGZyZXEpIHsgVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoKHRpbWUpID0+IHtcbiAgc3ludGhQYXJ0Mi5ldmVudHMgPSBiam9ya2x1bmQoYmdTcGxpdE1pbihuKSwgYmdTcGxpdE1heChuKSwgZnJlcSlcbiAgY29uc29sZS5sb2coc3ludGhQYXJ0Mi5ldmVudHMpXG4gIGNvbnNvbGUubG9nKG4pXG4gIFRvbmUuRHJhdy5zY2hlZHVsZSgoKSA9PiB7XG5cdFx0Ly8gZG8gZHJhd2luZyBvciBET00gbWFuaXB1bGF0aW9uIGhlcmVcbiAgIC8vIFZpc3VhbHMuZngzKC8qZnVuY3Rpb24oKXtsZXQgeSA9ICBmZnQuZ2V0VmFsdWUoKTsgcmV0dXJuIHlbMV0qMTAwMCArIDF9Ki9zLCBmdW5jdGlvbigpe2xldCB5ID0gIGZmdC5nZXRWYWx1ZSgpOyByZXR1cm4geVswXSoxMH0pO1xuLy9cdFZpc3VhbHMuZngyKCksXHRcbiAgIC8vY29uc29sZS5sb2codGltZSk7XG5cdH0sIHRpbWUpO1xufSwgcyk7fVxuXG4vL2Z1bmN0aW9uIGZvciBzY2hlZHVsaW5nIGNoYW5nZXMgaW4gdGhlIEJqb3JrbHVuZCByaHl0aG0gb2YgdGhlIHNwZWNpZmllZCBzeW50aCBwYXJ0IGFuZCBhbnkgb3RoZXIgY2hhbmdlIHRoYXQgd291bGQgYmUgc3luY2hvcm5pemVkIHdpdGggdGhlc2UgY2hhbmdlc1xuZnVuY3Rpb24gYmdFdmVudDMgKHMsIG4sIGZyZXEpIHsgVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoKHRpbWUpID0+IHtcbiAgc3ludGhQYXJ0My5ldmVudHMgPSBiam9ya2x1bmQoYmdTcGxpdE1pbihuKSwgYmdTcGxpdE1heChuKSwgZnJlcSlcbiAgY29uc29sZS5sb2coc3ludGhQYXJ0My5ldmVudHMpXG4gIGNvbnNvbGUubG9nKG4pXG4gIFRvbmUuRHJhdy5zY2hlZHVsZSgoKSA9PiB7XG5cdFx0Ly8gZG8gZHJhd2luZyBvciBET00gbWFuaXB1bGF0aW9uIGhlcmVcbiAgIC8vIFZpc3VhbHMuZngzKC8qZnVuY3Rpb24oKXtsZXQgeSA9ICBmZnQuZ2V0VmFsdWUoKTsgcmV0dXJuIHlbMV0qMTAwMCArIDF9Ki9zLCBmdW5jdGlvbigpe2xldCB5ID0gIGZmdC5nZXRWYWx1ZSgpOyByZXR1cm4geVswXSoxMH0pO1xuLy9cdFZpc3VhbHMuZng0KG4pLFx0XG4gICAvL2NvbnNvbGUubG9nKHRpbWUpO1xuXHR9LCB0aW1lKTtcbn0sIHMpO31cblxuLy9mdW5jdGlvbiBmb3Igc2NoZWR1bGluZyBjaGFuZ2VzIGluIHRoZSBCam9ya2x1bmQgcmh5dGhtIG9mIHRoZSBzcGVjaWZpZWQgc3ludGggcGFydCBhbmQgYW55IG90aGVyIGNoYW5nZSB0aGF0IHdvdWxkIGJlIHN5bmNob3JuaXplZCB3aXRoIHRoZXNlIGNoYW5nZXNcbmZ1bmN0aW9uIGJnRXZlbnQ0IChzLCBuLCBmcmVxKSB7IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKCh0aW1lKSA9PiB7XG4gIGtpY2tQYXJ0LmV2ZW50cyA9IGJqb3JrbHVuZChiZ1NwbGl0TWluKG4pLCBiZ1NwbGl0TWF4KG4pLCBmcmVxKVxuICBjb25zb2xlLmxvZyhraWNrUGFydC5ldmVudHMpXG4gIGNvbnNvbGUubG9nKG4pXG4gIFRvbmUuRHJhdy5zY2hlZHVsZSgoKSA9PiB7XG5cdFx0Ly8gZG8gZHJhd2luZyBvciBET00gbWFuaXB1bGF0aW9uIGhlcmVcbiAgIC8vIFZpc3VhbHMuZngzKC8qZnVuY3Rpb24oKXtsZXQgeSA9ICBmZnQuZ2V0VmFsdWUoKTsgcmV0dXJuIHlbMV0qMTAwMCArIDF9Ki9zLCBmdW5jdGlvbigpe2xldCB5ID0gIGZmdC5nZXRWYWx1ZSgpOyByZXR1cm4geVswXSoxMH0pO1xuLy9cdFZpc3VhbHMuZng0KG4pLFx0XG4gICAvL2NvbnNvbGUubG9nKHRpbWUpO1xuXHR9LCB0aW1lKTtcbn0sIHMpO31cblxuLy9oZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgYmdFdmVudCBmdW5jdGlvbnMsIE1pbiBzcGxpdHMgdGhlIEJHIG51bWJlciBhdCB0aGUgZGVjaW1hbCBhbmQgcmV0dXJucyB0aGUgc21hbGxlciBvZiB0aGUgdHdvIHJlc3VsdGluZyBpbnRlZ2VycywgTWF4IHJldHVybnMgdGhlIGxhcmdlclxuZnVuY3Rpb24gYmdTcGxpdE1pbiAobil7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLnJvdW5kKG4lMSoxMCksIE1hdGguZmxvb3IobikpXG59XG5mdW5jdGlvbiBiZ1NwbGl0TWF4IChuKXtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgucm91bmQobiUxKjEwKSwgTWF0aC5mbG9vcihuKSlcbn1cblxuLy9mdW5jdGlvbiBmb3Igc2NoZWR1bGluZyBjaGFuZ2VzIGluIHRoZSB2aXN1YWxzXG4vLyAgcyBpcyB3aGVuIGl0IHdpbGwgaGFwcGVuIC0gd2hlbiBpdCBpcyBzY2hlZHVsZWQgZm9yLlxuZnVuY3Rpb24gYmdWaXNFdmVudCAocykgeyBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZSgodGltZSkgPT4ge1xuICAgIFRvbmUuRHJhdy5zY2hlZHVsZSgoKSA9PiB7XG5cdFx0Ly8gZG8gZHJhd2luZyBvciBET00gbWFuaXB1bGF0aW9uIGhlcmVcblx0VmlzdWFscy5meDgoKTtcbiAgIGNvbnNvbGUubG9nKHRpbWUpO1xuXHR9LCB0aW1lKTtcbn0sIHMpO31cblxuLy9mdW5jdGlvbiBmb3Igc2NoZWR1bGluZyBjaGFuZ2VzIGluIHRoZSB2aXN1YWxzXG4vLyAgcyBpcyB3aGVuIGl0IHdpbGwgaGFwcGVuIC0gd2hlbiBpdCBpcyBzY2hlZHVsZWQgZm9yLlxuZnVuY3Rpb24gYmdWaXNFdmVudDIgKHMsIGcsIGludiwgc2F0LCBubiwgbnMsIHJvdCwgbHRocnNoLCBsdG9sKSB7IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKCh0aW1lKSA9PiB7XG4gIFRvbmUuRHJhdy5zY2hlZHVsZSgoKSA9PiB7XG4gIC8vIGRvIGRyYXdpbmcgb3IgRE9NIG1hbmlwdWxhdGlvbiBoZXJlXG5WaXN1YWxzLmZ4NyhnLCBpbnYsIHNhdCwgbm4sIG5zLCByb3QsIGx0aHJzaCwgbHRvbClcdFxuIGNvbnNvbGUubG9nKHRpbWUpO1xufSwgdGltZSk7XG59LCBzKTt9XG5cbi8vIHRoaXMgd29ya3MgYXMgYSBiYXNpYyBvcmdhbml6YXRpb25hbCBsb2dpYyAtIHN0aWxsIG5lZWQgdG8gd29yayBvdXQgY29vcmRpbmF0aW9uIG9mIHNvdW5kIGFuZCB2aXN1YWwgZXZlbnRzIHdoaWNoIG1pZ2h0IG5vdCBhbHdheXMgY2hhbmdlIGF0IHRoZSBzYW1lIHRpbWVcbi8vd2l0aCB0aGUgY3VycmVudCBCRyBldmVudHMgdGhleSBrZWVwIGdvaW5nIHdpdGggdGhlaXIgY3VycmVudCBkYXRhIHVudGlsIHRoZXkgcmVjZWl2ZSBhIGNoYW5nZVxuLy9maXJzdCB2YXJpYWJsZSBvZiB0aGUgQkcgZXZlbnQgaXMgd2hlbiBpdCBpcyBzY2hlZHVsZWQgdG8gaGFwcGVuLCBzZWNvbmQgaXMgdGhlIEJHIHZhbHVlXG5cblxuLy9PdmVyYXJjaGluZyBzdHJ1Y3V0cmUgb2YgdGhlIGdlbmVyYXRpdmUgY29tcG9zaXRpb246IDEpIGNyZWF0ZSBhcyBtYW55IFRpbWUgY291bnRlcnMgYXMgbmVjZXNzYXJ5OyBhIG5ldyBUaW1lIGNvdW50ZXIgaXMgbmVjZXNzYXJ5IGZvciBhbnkgY2hhbmdlIHRoYXQgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHNhbWUgdGltZSBhcyBhbiBleGlzdGluZyBjaGFuZ2UgKHdoaWNoIHdpbGwgYWxyZWFkeSBoYXZlIGl0cyBvd24gVGltZSBjb3VudGVyKVxuLy8yKSBVc2luZyBhIGZvciBsb29wLCBnbyB0aHJvdWdoIGFsbCB0aGUgZ2x1Y29zZSB2YWx1ZXMgYW5kIGNyZWF0ZSBhIHNjb3JlIGZyb20gdGhhdDsgdGhpcyBpcyB3aGVyZSB0aGUgdGltaW5nIG9mIGNoYW5nZXMgaXMgZGV0ZXJtaW5lZCwgYXMgd2VsbCBhcyB3aGF0IGRhdGEgaXMgZmVkIGludG8gdGhlIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hhbmdlcyBhcmVcbmxldCBiZ1RpbWUgPSAwO1xubGV0IGJnVGltZUIgPSAwOyAvL2lmIHlvdSBkb24ndCB3YW50IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgYXQgb25jZSB5b3UgY2FuIG1ha2UgYW4gb2Zmc2V0IChleC4gc2V0IGJnVGltZUIgdG8gZ2x1Y29zZVZhbHVlc1sxXSlcbmxldCBiZ1RpbWVDID0gMDsgLy9pZiB5b3UgZG9uJ3Qgd2FudCBldmVyeXRoaW5nIHRvIHN0YXJ0IGF0IG9uY2UgeW91IGNhbiBtYWtlIGFuIG9mZnNldCAoZXguIHNldCBiZ1RpbWVDIHRvIGdsdWNvc2VWYWx1ZXNbMl0pXG5sZXQgYmdUaW1lMiA9IDA7XG4vL0ZJR1VSRSBPVVQgSE9XIFRPIExPT1BcbmZvciAobGV0IGkgPSAwOyBpIDwgZ2x1Y29zZVZhbHVlcy5sZW5ndGg7IGkrKylcbntcbiAgbGV0IGJnID0gZ2x1Y29zZVZhbHVlc1tpXTtcbiAgLy9jb25kaXRpb25hbCBzdGF0ZW1lbnRzIHRvIGFsbG93IHRoZSBwb3NzaWJpbGl0eSBvZiBkaWZmZXJlbnQgdGhpbmdzIGhhcHBlbmluZyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgQkcgcmVhZGluZyBpcyBoaWdoLCBvbiB0YXJnZXQsIG9yIGxvdyAoY291bGQgYWRkIG1vcmUgY29uZGl0aW9ucyBhbmQvb3IgY2hhbmdlIGV4aXN0aW5nIHRocmVzaG9sZHMpXG4gIGlmIChiZyA+PSA4LjApe1xuICAgIGNvbnNvbGUubG9nKFwiaGlnaCBcIiwgZ2x1Y29zZVZhbHVlc1tpXSwgYmdUaW1lLCBiZ0ZyZXFzW2ldKVxuICAgIC8vZG8gc29tZXRoaW5nIGhlcmVcbiAgICAvL3N3ZWxsIGV2ZW50IGhhcHBlbnMgYXQgdGhlIGRlc2lnbmF0ZWQgdGltZSBhbmQgd2l0aCB0aGUgZGVzaWduYXRlZCBGcmVxdWVjeSB2YWx1ZSAobXVsdGlwbGljYXRpb24gYnkgMC41IHdvdWxkIGxvd2VyIGl0IGJ5IDEgb2N0YXZlKVxuICAgIHN3ZWxsRk1FdmVudDEoYmdUaW1lLCBiZ0ZyZXFzW2ldKjAuMTI1LCBiZ1JhbmdlMDFbaV0sIGJnUmFuZ2UwMVtpXSoyICk7IFxuICAgIC8vYmdFdmVudHMgYXJlIHRoZSBFdWNsaWRlYW4gcmh5dGhtcywgaGVyZSB3ZSBkZXRlcm1pbmUgd2hlbiB0aGV5IGNoYW5nZSAoZXguIGJnVGltZSksIHdoYXQgcmh5dGhtIHRoZXkgY2hhbmdlIHRvIChleC4gZ2x1Y29zZVZhbHVlc1tpXSksIGFuZCB3aGF0IGZyZXF1ZW5jeS9ub3RlIGlzIHBsYXllZCAoZXguIGJnIEZyZXFzW2ldKVxuICAgIGJnRXZlbnQoYmdUaW1lLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ0ZyZXFzW2ldKTtcbiAgICB0aW1icmVTaGlmdChiZ1RpbWUsIGZtU3ludGgsIDEuNSwgZm1NSU9mZnNldCpiZ1JhbmdlMDFbaV0pO1xuICAgIGJnRXZlbnQyKGJnVGltZUIsIGdsdWNvc2VWYWx1ZXNbKGkrMSklZ2x1Y29zZVZhbHVlcy5sZW5ndGhdLCBiZ0ZyZXFzWyhpKzEpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSk7XG4gICAgdGltYnJlU2hpZnQoYmdUaW1lQiwgZm1TeW50aDIsIDEuNSwgZm1NSU9mZnNldCpiZ1JhbmdlMDFbKGkrMSklZ2x1Y29zZVZhbHVlcy5sZW5ndGhdKTtcbiAgICBiZ0V2ZW50MyhiZ1RpbWVDLCBnbHVjb3NlVmFsdWVzWyhpKzIpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSwgYmdGcmVxc1soaSsyKSVnbHVjb3NlVmFsdWVzLmxlbmd0aF0pO1xuICAgIHRpbWJyZVNoaWZ0KGJnVGltZUMsIGZtU3ludGgzLCAxLjUsIGZtTUlPZmZzZXQqYmdSYW5nZTAxWyhpKzIpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSk7XG4gICAgYmdFdmVudDQoYmdUaW1lLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ0ZyZXFzW2ldKjAuMTI1KTtcbi8vc2NoZWR1bGluZyBvZiBhIGNoYW5nZSBpbiB0aGUgdmlzdWFscywgZmlyc3QgdmFyaWFibGUgZGV0ZXJtaW5lcyB3aGVuLCB0aGUgcmVzdCBkZXBlbmQgb24gdGhlIHZpc3VhbCBzeW50aCBpbiBxdWVzdGlvblxuLy9iZ1Zpc0V2ZW50MihiZ1RpbWUyLCBiZ1JhbmdlMDFbaV0sIGJnUmFuZ2UwMVtpKzFdLCBiZ1JhbmdlOVtpKzJdLCBiZ1JhbmdlOVtpKzddLCBiZ1JhbmdlMDFbaSszXSwgYmdSYW5nZTMxMFtpKzRdLCBiZ1JhbmdlMTAwW2krNV0sIGJnUmFuZ2UzMDBbaSs2XSlcbiAgICAvL2JnVmlzRXZlbnQyKGJnVGltZSwgYmdSYW5nZTAxW2ldLCBiZ1JhbmdlMDFbaV0sIGJnUmFuZ2U5W2ldLGJnUmFuZ2U5W2ldLCBiZ1JhbmdlMDFbaV0sIGJnUmFuZ2UzMTBbaV0sIGJnUmFuZ2UxMDBbaV0sIGJnUmFuZ2UzMDBbaV0pXG4gIH0gZWxzZVxuICBpZiAoYmc8PSA3LjkgJiYgYmc+PTQuMCApe1xuICAgIGNvbnNvbGUubG9nKFwidGFyZ2V0IFwiLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ1RpbWUsIGJnRnJlcXNbaV0pXG4gICAgLy9kbyBzb21ldGhpbmcgaGVyZVxuICAgc3dlbGxGTUV2ZW50MShiZ1RpbWUsIGJnRnJlcXNbaV0qMC4xMjUsIGJnUmFuZ2UwMVtpXSwgYmdSYW5nZTAxW2ldKjUpOyBcbiAgIGJnRXZlbnQoYmdUaW1lLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ0ZyZXFzW2ldKTtcbiAgIHRpbWJyZVNoaWZ0KGJnVGltZSwgZm1TeW50aCwgMS41LCBmbU1JT2Zmc2V0KmJnUmFuZ2UwMVtpXSk7XG4gICBiZ0V2ZW50MihiZ1RpbWVCLCBnbHVjb3NlVmFsdWVzWyhpKzEpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSwgYmdGcmVxc1soaSsxKSVnbHVjb3NlVmFsdWVzLmxlbmd0aF0pO1xuICAgdGltYnJlU2hpZnQoYmdUaW1lQiwgZm1TeW50aDIsIDEuNSwgZm1NSU9mZnNldCpiZ1JhbmdlMDFbKGkrMSklZ2x1Y29zZVZhbHVlcy5sZW5ndGhdKTtcbiAgIGJnRXZlbnQzKGJnVGltZUMsIGdsdWNvc2VWYWx1ZXNbKGkrMiklZ2x1Y29zZVZhbHVlcy5sZW5ndGhdLCBiZ0ZyZXFzWyhpKzIpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSk7XG4gICB0aW1icmVTaGlmdChiZ1RpbWVDLCBmbVN5bnRoMywgMS41LCBmbU1JT2Zmc2V0KmJnUmFuZ2UwMVsoaSsyKSVnbHVjb3NlVmFsdWVzLmxlbmd0aF0pO1xuICAgYmdFdmVudDQoYmdUaW1lLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ0ZyZXFzW2ldKjAuMTI1KTtcblxuICAgLy9iZ1Zpc0V2ZW50MihiZ1RpbWUyLCBiZ1JhbmdlMDFbaV0sIGJnUmFuZ2UwMVtpKzFdLCBiZ1JhbmdlOVtpKzJdLCBiZ1JhbmdlOVtpKzddLCBiZ1JhbmdlMDFbaSszXSwgYmdSYW5nZTMxMFtpKzRdLCBiZ1JhbmdlMTAwW2krNV0sIGJnUmFuZ2UzMDBbaSs2XSlcbiAgLy8gYmdWaXNFdmVudDIoYmdUaW1lLCBiZ1JhbmdlMDFbaV0sIGJnUmFuZ2UwMVtpXSwgYmdSYW5nZTlbaV0sYmdSYW5nZTlbaV0sIGJnUmFuZ2UwMVtpXSwgYmdSYW5nZTMxMFtpXSwgYmdSYW5nZTEwMFtpXSwgYmdSYW5nZTMwMFtpXSlcbiAgfSBlbHNlXG4gIGlmIChiZyA8IDQuMCl7XG4gICAgY29uc29sZS5sb2coXCJsb3cgXCIsIGdsdWNvc2VWYWx1ZXNbaV0sIGJnVGltZSwgYmdGcmVxc1tpXSlcbiAgICAvL2RvIHNvbWV0aGluZyBoZXJlXG4gICAgc3dlbGxGTUV2ZW50MShiZ1RpbWUsIGJnRnJlcXNbaV0qMC4xMjUsIGJnUmFuZ2UwMVtpXSwgYmdSYW5nZTAxW2ldKjIpOyBcbiBcbiAgIGJnRXZlbnQoYmdUaW1lLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ0ZyZXFzW2ldKTtcbiAgIHRpbWJyZVNoaWZ0KGJnVGltZSwgZm1TeW50aCwgMS41LCBmbU1JT2Zmc2V0KmJnUmFuZ2UwMVtpXSk7XG4gICBiZ0V2ZW50MihiZ1RpbWVCLCBnbHVjb3NlVmFsdWVzWyhpKzEpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSwgYmdGcmVxc1soaSsxKSVnbHVjb3NlVmFsdWVzLmxlbmd0aF0pO1xuICAgdGltYnJlU2hpZnQoYmdUaW1lQiwgZm1TeW50aDIsIDEuNSwgZm1NSU9mZnNldCpiZ1JhbmdlMDFbKGkrMSklZ2x1Y29zZVZhbHVlcy5sZW5ndGhdKTtcbiAgIGJnRXZlbnQzKGJnVGltZUMsIGdsdWNvc2VWYWx1ZXNbKGkrMiklZ2x1Y29zZVZhbHVlcy5sZW5ndGhdLCBiZ0ZyZXFzWyhpKzIpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSk7XG4gICB0aW1icmVTaGlmdChiZ1RpbWVDLCBmbVN5bnRoMywgMS41LCBmbU1JT2Zmc2V0KmJnUmFuZ2UwMVsoaSsyKSVnbHVjb3NlVmFsdWVzLmxlbmd0aF0pO1xuICAgYmdFdmVudDQoYmdUaW1lLCBnbHVjb3NlVmFsdWVzW2ldLCBiZ0ZyZXFzW2ldKjAuMTI1KTtcbiAgICAvL2JnVmlzRXZlbnQyKGJnVGltZTIsIGJnUmFuZ2UwMVtpXSwgYmdSYW5nZTAxW2krMV0sIGJnUmFuZ2U5W2krMl0sIGJnUmFuZ2U5W2krN10sIGJnUmFuZ2UwMVtpKzNdLCBiZ1JhbmdlMzEwW2krNF0sIGJnUmFuZ2UxMDBbaSs1XSwgYmdSYW5nZTMwMFtpKzZdKVxuICAvLyBiZ1Zpc0V2ZW50MihiZ1RpbWUsIGJnUmFuZ2UwMVtpXSwgYmdSYW5nZTAxW2ldLCBiZ1JhbmdlOVtpXSxiZ1JhbmdlOVtpXSwgYmdSYW5nZTAxW2ldLCBiZ1JhbmdlMzEwW2ldLCBiZ1JhbmdlMTAwW2ldLCBiZ1JhbmdlMzAwW2ldKVxuICB9XG4gICAgLy9kaWZmZXJlbmNlcyBpbiB0aW1pbmcgZm9yIGRpZmZlcmVudCBzdHJlYW1zIG9mIGV2ZW50c1xuICAvL211bHRpcGxpY2F0aW9uIGZhY3RvciBkZXRlcm1pbmVzIGhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGNoYW5naW5nXG4gIC8vYWRkaXRpb24gaW4gdGhlIGJyYWNrZXQgZGV0ZXJtaW5lcyBvZmZzZXQgb2YgQkcgdmFsdWUgZnJvbSBkYXRhc2V0XG4gIGJnVGltZSA9IGJnVGltZSArIGdsdWNvc2VWYWx1ZXNbaV0qMTtcbiAgYmdUaW1lQiA9IGJnVGltZUIgKyBnbHVjb3NlVmFsdWVzWyhpKzEpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSoxOy8vbmVlZCB0aGUgbW9kdWxvIGJlY2F1c2Ugb2YgdGhlIG9mZnNldCAoaSsxKSwgc28gaXQgY2FuIHdyYXAgYmFjayBhcm91bmRcbiAgYmdUaW1lQyA9IGJnVGltZUMgKyBnbHVjb3NlVmFsdWVzWyhpKzIpJWdsdWNvc2VWYWx1ZXMubGVuZ3RoXSoxOy8vbmVlZCB0aGUgbW9kdWxvIGJlY2F1c2Ugb2YgdGhlIG9mZnNldCAoaSsyKSwgc28gaXQgY2FuIHdyYXAgYmFjayBhcm91bmRcbiAgYmdUaW1lMiA9IGJnVGltZTIgKyBnbHVjb3NlVmFsdWVzW2ldKjM7XG4gIGNvbnNvbGUubG9nKFwiYmdUaW1lQlwiICsgYmdUaW1lQikgXG5jb25zb2xlLmxvZyhcImJnVGltZUNcIiArIGJnVGltZUMpIFxufVxuY29uc29sZS5sb2coXCJiZ1RpbWVcIiArIGJnVGltZSlcbmNvbnNvbGUubG9nKFwiYmdUaW1lQlwiICsgYmdUaW1lQikgXG5jb25zb2xlLmxvZyhcImJnVGltZUNcIiArIGJnVGltZUMpICBcbi8vY29uc29sZS5sb2coY2FsY0JQTSpiZ1RpbWUqMC4wMTY2NyowLjI1KTtcbi8vY29uc29sZS5sb2coY2FsY0JQTSpiZ1RpbWUqMC4wMTY2NyowLjI1JU1hdGguZmxvb3IoY2FsY0JQTSpiZ1RpbWUqMC4wMTY2NyowLjI1KSlcbmNvbnN0IGJhcnMgPSBNYXRoLmZsb29yKGNhbGNCUE0qKGJnVGltZSkqMC4wMTY2NyowLjI1KVxuY29uc3QgYmVhdHMgPSBNYXRoLmZsb29yKChjYWxjQlBNKihiZ1RpbWUpKjAuMDE2NjcqMC4yNSVNYXRoLmZsb29yKGNhbGNCUE0qKGJnVGltZSkqMC4wMTY2NyowLjI1KSkqNClcbmNvbnNvbGUubG9nKGJhcnMpO1xuY29uc29sZS5sb2coYmVhdHMpO1xuY29uc29sZS5sb2cgKGJhcnMgKyBcIjpcIisgYmVhdHMpO1xuXG5jb25zdCBlbmRMb29wID0gYmFycyArIFwiOlwiKyBiZWF0cyAvLzQgKyBcIjpcIiArIDE7LypjYWxjQlBNKihiZ1RpbWUrMi45KzMuNisxMikqMC4wMTY2NyowLjI1Ki9cblxuVG9uZS5UcmFuc3BvcnQuc2V0TG9vcFBvaW50cygwLCBlbmRMb29wKTtcblx0IFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlO1xufTtcblxuXG5cbi8vICogIFNjaGVkdWxpbmdcbmV4cG9ydCBjb25zdCBwbGF5U2NoZWR1bGluZyA9IGFzeW5jICgpID0+IHtcbiAgYXdhaXQgVG9uZS5zdGFydCgpO1xuICAvL3Byb29mIG9mIGNvbmNlcHQgLSB0aGUgYmdEYXRhIG51bWJlcnMgYXJlIHJvdW5kZWQgb2ZmIGFuZCB1c2VzIGFzIGluZGljZXMgZm9yIHRoZSBub3Rlc0FycmF5IGluIHRoZSBUb25lLlNlcXVlbmNlIGJlbG93XG4gIGNvbnN0IGJnRGF0YTogbnVtYmVyW10gPSBbNS43LCAyLjMsIDExLjgsIDkuNSwgNy44XTtcbiAgY29uc3Qgbm90ZXNBcnJheTogc3RyaW5nW10gPSBbXG4gICAgJ0MzJyxcbiAgICAnQTMnLFxuICAgICdHMycsXG4gICAgJ0UzJyxcbiAgICAnQzInLFxuICAgICdDMycsXG4gICAgJ0EzJyxcbiAgICAnRzMnLFxuICAgICdFMycsXG4gICAgJ0MyJyxcbiAgICAnQzMnLFxuICAgICdBMycsXG4gICAgJ0czJyxcbiAgICAnRTMnLFxuICAgICdDMicsXG4gIF07XG5cbiAgY29uc3Qgc3ludGhBID0gbmV3IFRvbmUuRk1TeW50aCgpLnRvRGVzdGluYXRpb24oKTtcbiAgY29uc3Qgc3ludGhCID0gbmV3IFRvbmUuQU1TeW50aCgpLnRvRGVzdGluYXRpb24oKTtcblxuICAvL3BsYXkgYSBub3RlIGV2ZXJ5IHF1YXJ0ZXItbm90ZVxuICAvKmNvbnN0IGxvb3BBID0gbmV3IFRvbmUuTG9vcCgodGltZSkgPT4ge1xuICAgIHN5bnRoQS50cmlnZ2VyQXR0YWNrUmVsZWFzZSgnQzInLCAnOG4nLCB0aW1lKTtcbiAgfSwgJzRuJykuc3RhcnQoMCk7Ki9cblxuICBjb25zdCBzZXEgPSBuZXcgVG9uZS5TZXF1ZW5jZShcbiAgICAodGltZSwgbm90ZSkgPT4ge1xuICAgICAgc3ludGhBLnRyaWdnZXJBdHRhY2tSZWxlYXNlKG5vdGUsIDAuMSwgdGltZSk7XG4gICAgICAvLyBzdWJkaXZpc2lvbnMgYXJlIGdpdmVuIGFzIHN1YmFycmF5c1xuICAgIH0sXG4gICAgW1xuICAgICAgbm90ZXNBcnJheVtNYXRoLnJvdW5kKGJnRGF0YVswXSldLFxuICAgICAgW25vdGVzQXJyYXlbMV0sIG5vdGVzQXJyYXlbMl0sIG5vdGVzQXJyYXlbM11dLFxuICAgICAgbm90ZXNBcnJheVtNYXRoLnJvdW5kKGJnRGF0YVszXSldLFxuICAgICAgW25vdGVzQXJyYXlbM10sIG5vdGVzQXJyYXlbNF1dLFxuICAgIF1cbiAgKS5zdGFydCgwKTtcblxuICAvL3BsYXkgYW5vdGhlciBub3RlIGV2ZXJ5IG9mZiBxdWFydGVyLW5vdGUsIGJ5IHN0YXJ0aW5nIGl0IFwiOG5cIlxuICBjb25zdCBsb29wQiA9IG5ldyBUb25lLkxvb3AoKHRpbWUpID0+IHtcbiAgICBzeW50aEIudHJpZ2dlckF0dGFja1JlbGVhc2UoJ0cyJywgJzhuJywgdGltZSk7XG4gIH0sICc0bicpLnN0YXJ0KCc4bicpO1xuICAvLyBhbGwgbG9vcHMgc3RhcnQgdW50aWwgdGhlIFRyYW5zcG9ydCBpcyBzdGFydGVkXG4gIFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSA9IDgwO1xuICBUb25lLlRyYW5zcG9ydC5zdGFydCgpO1xuICAvL1RvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzFcIiwgXCIyOjA6MFwiKTsvLyB0aGlzIHdvcmtzXG5cbiAgLy8gc2NoZWR1bGUgYW4gZXZlbnQgb24gdGhlIDJuZCBtZWFzdXJlXG4gIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKCh0aW1lKSA9PiB7XG4gICAgLy8gaW52b2tlZCBvbiBtZWFzdXJlIDJcblxuICAgIGNvbnNvbGUubG9nKCdtZWFzdXJlIDIhJyk7XG5cbiAgICBzZXEuc3RvcCgpO1xuICAgIC8vc3ludGhCLmVudmVsb3BlLmF0dGFjayA9IDAuNjtcbiAgICBzeW50aEIuc2V0KHtcbiAgICAgIGhhcm1vbmljaXR5OiAwLjEsXG4gICAgICBlbnZlbG9wZToge1xuICAgICAgICBhdHRhY2s6IDAuMSxcbiAgICAgICAgcmVsZWFzZTogMC4xLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvL1RvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSA9IDE0MDsvLyBub3Qgc3VyZSBob3cgdG8gbWFrZSB0aGlzIHdvcmsgcHJvcGVybHlcbiAgfSwgJzI6MDowJyk7XG5cbiAgLy8gc2NoZWR1bGUgYW4gZXZlbnQgb24gdGhlIDR0aCBtZWFzdXJlXG4gIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKCh0aW1lKSA9PiB7XG4gICAgLy8gaW52b2tlZCBvbiBtZWFzdXJlIDJcbiAgICAvLyBsb29wQS5zdG9wKHRpbWUpO1xuICAgIGNvbnNvbGUubG9nKCdtZWFzdXJlIDQhJyk7XG4gICAgLy9zeW50aEIuc2V0Tm90ZSgnRjMnKTtcbiAgICBzZXEuc3RhcnQoKTtcbiAgICAvL3N5bnRoQi5lbnZlbG9wZS5hdHRhY2sgPSAwLjY7XG4gICAgc3ludGhCLmhhcm1vbmljaXR5LnJhbXBUbygxNSwgMik7XG4gICAgLy9zeW50aEIuaGFybW9uaWNpdHkudmFsdWUgPSAxNTtcbiAgfSwgJzQ6MDowJyk7XG59O1xuXG4vLyogIEluc3RydW1lbnRzXG5leHBvcnQgY29uc3QgcGxheUluc3RydW1lbnRzID0gYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBUb25lLnN0YXJ0KCk7XG5cbiAgLy9wYXNzIGluIHNvbWUgaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBmaWx0ZXIgYW5kIGZpbHRlciBlbnZlbG9wZVxuICBjb25zdCBzeW50aCA9IG5ldyBUb25lLlBvbHlTeW50aChUb25lLlN5bnRoKS50b0Rlc3RpbmF0aW9uKCk7XG4gIGNvbnN0IG5vdyA9IFRvbmUubm93KCk7XG4gIHN5bnRoLnRyaWdnZXJBdHRhY2soJ0Q0Jywgbm93KTtcbiAgc3ludGgudHJpZ2dlckF0dGFjaygnRjQnLCBub3cgKyAwLjUpO1xuICBzeW50aC50cmlnZ2VyQXR0YWNrKCdBNCcsIG5vdyArIDEpO1xuICBzeW50aC50cmlnZ2VyQXR0YWNrKCdDNCcsIG5vdyArIDEuNSk7XG4gIHN5bnRoLnRyaWdnZXJBdHRhY2soJ0U0Jywgbm93ICsgMik7XG4gIHN5bnRoLnRyaWdnZXJSZWxlYXNlKFsnRDQnLCAnRjQnLCAnQTQnLCAnQzQnLCAnRTQnXSwgbm93ICsgNCk7XG59O1xuXG4vLyogIFNhbXBsZXNcbmV4cG9ydCBjb25zdCBwbGF5U2FtcGxlcyA9IGFzeW5jICgpID0+IHtcbiAgYXdhaXQgVG9uZS5zdGFydCgpO1xuXG4gIGNvbnN0IHBsYXllciA9IG5ldyBUb25lLlBsYXllcihcbiAgICAnaHR0cHM6Ly90b25lanMuZ2l0aHViLmlvL2F1ZGlvL2JlcmtsZWUvZ29uZ18xLm1wMydcbiAgKS50b0Rlc3RpbmF0aW9uKCk7XG4gIFRvbmUubG9hZGVkKCkudGhlbigoKSA9PiB7XG4gICAgcGxheWVyLnN0YXJ0KCk7XG4gIH0pO1xufTtcblxuLy8qICBTYW1wbGVyXG5leHBvcnQgY29uc3QgcGxheVNhbXBsZXIgPSBhc3luYyAoKSA9PiB7XG4gIGF3YWl0IFRvbmUuc3RhcnQoKTtcblxuICBjb25zdCBzYW1wbGVyID0gbmV3IFRvbmUuU2FtcGxlcih7XG4gICAgdXJsczoge1xuICAgICAgQzQ6ICdDNC5tcDMnLFxuICAgICAgJ0QjNCc6ICdEczQubXAzJyxcbiAgICAgICdGIzQnOiAnRnM0Lm1wMycsXG4gICAgICBBNDogJ0E0Lm1wMycsXG4gICAgfSxcbiAgICBiYXNlVXJsOiAnaHR0cHM6Ly90b25lanMuZ2l0aHViLmlvL2F1ZGlvL3NhbGFtYW5kZXIvJyxcbiAgfSkudG9EZXN0aW5hdGlvbigpO1xuXG4gIFRvbmUubG9hZGVkKCkudGhlbigoKSA9PiB7XG4gICAgc2FtcGxlci50cmlnZ2VyQXR0YWNrUmVsZWFzZShbJ0ViNCcsICdHNCcsICdCYjQnXSwgMC41KTtcbiAgfSk7XG59O1xuXG4vLyogIEVmZWN0c1xuZXhwb3J0IGNvbnN0IHBsYXlFZmZlY3R0cyA9IGFzeW5jICgpID0+IHtcbiAgYXdhaXQgVG9uZS5zdGFydCgpO1xuXG4gIGNvbnN0IHBsYXllciA9IG5ldyBUb25lLlBsYXllcih7XG4gICAgdXJsOiAnaHR0cHM6Ly90b25lanMuZ2l0aHViLmlvL2F1ZGlvL2JlcmtsZWUvZ3VyZ2xpbmdfdGhlcmVtaW5fMS5tcDMnLFxuICAgIGxvb3A6IGZhbHNlLFxuICAgIGF1dG9zdGFydDogdHJ1ZSxcbiAgfSk7XG4gIC8vY3JlYXRlIGEgZGlzdG9ydGlvbiBlZmZlY3RcbiAgY29uc3QgZGlzdG9ydGlvbiA9IG5ldyBUb25lLkRpc3RvcnRpb24oMC40KS50b0Rlc3RpbmF0aW9uKCk7XG4gIC8vY29ubmVjdCBhIHBsYXllciB0byB0aGUgZGlzdG9ydGlvblxuICBwbGF5ZXIuY29ubmVjdChkaXN0b3J0aW9uKTtcbn07XG5cbi8vKiAgU2lnbmFsc1xuZXhwb3J0IGNvbnN0IHBsYXlTaWduYWwgPSBhc3luYyAoKSA9PiB7XG4gIGF3YWl0IFRvbmUuc3RhcnQoKTtcblxuICBjb25zdCBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9EZXN0aW5hdGlvbigpO1xuICAvLyBzdGFydCBhdCBcIkM0XCJcbiAgb3NjLmZyZXF1ZW5jeS52YWx1ZSA9ICdDNCc7XG4gIC8vIHJhbXAgdG8gXCJDNVwiIG92ZXIgMiBzZWNvbmRzXG4gIG9zYy5mcmVxdWVuY3kucmFtcFRvKCdDNScsIDIpO1xufTtcblxuXG5cbiJdLCJuYW1lcyI6WyJUb25lIiwiVmlzdWFscyIsImRhdGEiLCJfIiwiZ2x1Y29zZVZhbHVlcyIsImZpbHRlciIsInZhbHVlIiwiZ2x1Y29zZSIsIm1hcCIsIk51bWJlciIsIm1pZEdsdWNvc2UiLCJhdCIsIk1hdGgiLCJmbG9vciIsImxlbmd0aCIsImF2Z0dsdWNvc2UiLCJyZWR1Y2UiLCJwcmV2aW91c1ZhbHVlIiwiY3VycmVudFZhbHVlIiwiY2FsY01vZGUiLCJyb3VuZCIsImNhbGNLZXkiLCJicG1JbmRleCIsImJwbVJhbmdlIiwiY2FsY0JQTSIsImNvbnZlcnRSYW5nZSIsImNvbnNvbGUiLCJsb2ciLCJpbnRlckJHQXJyYXkiLCJpbnRlckp1bXAiLCJwYXJ0QXJyYXkxIiwic2xpY2UiLCJwYXJ0QXJyYXkyIiwicGFydEFycmF5MyIsImkiLCJwdXNoIiwicjEiLCJyMiIsIm1heEJHIiwibWF4IiwibWluQkciLCJtaW4iLCJiZ1JhbmdlMDEiLCJudW0iLCJiZ1JhbmdlOSIsImJnUmFuZ2UzMTAiLCJiZ1JhbmdlMTAwIiwiYmdSYW5nZTMwMCIsIm1ham9yRm9ybXVsYSIsIm1vZGVOYW1lcyIsIm15TW9kZU51bSIsIm15S2V5IiwibXlNb2RlRm9ybXVsYSIsIm1ha2VNb2RlRm9ybXVsYSIsInBhcmVudFNjYWxlRm9ybXVsYSIsIm1vZGVOdW0iLCJyb290IiwiZm9ybXVsYUxlbmd0aCIsInNjYWxlSW5kZXgiLCJtb2RlRm9ybXVsYSIsIm1vZGVJbnRlcnZhbCIsInRvU3RyaW5nIiwiY29udmVydEJHdG9Ob3RlcyIsInVwcGVyTGltaXQiLCJiYXNlT2N0YXZlIiwiYmdTY2FsZURlZ3MiLCJiZ0ludGVydmFscyIsInJldmVyYkEiLCJSZXZlcmIiLCJwYW5Wb2xTMSIsIlBhblZvbCIsInRvRGVzdGluYXRpb24iLCJwYW5Wb2xTMiIsInBhblZvbFMzIiwicGFuVm9sSzEiLCJraWNrU3ludGgiLCJNZW1icmFuZVN5bnRoIiwic3ludGgiLCJQbHVja1N5bnRoIiwic3ludGgyIiwic3ludGgzIiwiZm1TeW50aCIsIkZNU3ludGgiLCJmbVN5bnRoMiIsImZtU3ludGgzIiwiZm1NSU9mZnNldCIsImZtU3dlbGwiLCJzZXQiLCJoYXJtb25pY2l0eSIsIm1vZHVsYXRpb25JbmRleCIsImVudmVsb3BlIiwiYXR0YWNrIiwibW9kdWxhdGlvbkVudmVsb3BlIiwiZGVjYXkiLCJzdXN0YWluIiwibW9kdWxhdGlvbiIsInR5cGUiLCJvc2NpbGxhdG9yIiwiY29ubmVjdCIsImNoYWluIiwiRGVzdGluYXRpb24iLCJwbGF5U2ltcGxlIiwic3RhcnQiLCJ4IiwiZng1IiwidHJpZ2dlckF0dGFja1JlbGVhc2UiLCJiZyIsInBsYXlUaW1lQ29udHJvbCIsIm5vdyIsInBsYXlTcXVlbmNlIiwiZmZ0IiwiRkZUIiwibm9ybWFsUmFuZ2UiLCJzbW9vdGhpbmciLCJjb3VudGVyUzFWZWwiLCJjb3VudGVyUzJWZWwiLCJjb3VudGVyUzNWZWwiLCJiZ01JREkiLCJiZ0ZyZXFzIiwibXRvZiIsImZ4OCIsImZmdE5vcm0iLCJiam9ya2x1bmQiLCJrIiwibiIsImMiLCJzZXEiLCJ0aW1lcyIsImNvbnN0YW50IiwiY29uY2F0IiwiaGVhZCIsInJlbWFpbmRlciIsInBhcnRpdGlvbiIsImlzRXF1YWwiLCJwb3AiLCJmbGF0dGVuIiwibm90ZXMiLCJub3RlczIiLCJub3RlczMiLCJraWNrIiwic3ludGhQYXJ0IiwiU2VxdWVuY2UiLCJ0aW1lIiwibm90ZSIsInN5bnRoUGFydDIiLCJzeW50aFBhcnQzIiwia2lja1BhcnQiLCJUcmFuc3BvcnQiLCJicG0iLCJzd2VsbEZNRXZlbnQxIiwicyIsImZyZXEiLCJhdGsiLCJkdXIiLCJzY2hlZHVsZSIsInRpbWJyZVNoaWZ0Iiwic3ludGhOYW1lIiwiaGFybW9uIiwibW9kaW5kZXgiLCJiZ0V2ZW50IiwiZXZlbnRzIiwiYmdTcGxpdE1pbiIsImJnU3BsaXRNYXgiLCJEcmF3IiwieSIsImdldFZhbHVlIiwiYmdFdmVudDIiLCJiZ0V2ZW50MyIsImJnRXZlbnQ0IiwiYmdWaXNFdmVudCIsImJnVmlzRXZlbnQyIiwiZyIsImludiIsInNhdCIsIm5uIiwibnMiLCJyb3QiLCJsdGhyc2giLCJsdG9sIiwiZng3IiwiYmdUaW1lIiwiYmdUaW1lQiIsImJnVGltZUMiLCJiZ1RpbWUyIiwiYmFycyIsImJlYXRzIiwiZW5kTG9vcCIsInNldExvb3BQb2ludHMiLCJsb29wIiwicGxheVNjaGVkdWxpbmciLCJiZ0RhdGEiLCJub3Rlc0FycmF5Iiwic3ludGhBIiwic3ludGhCIiwiQU1TeW50aCIsImxvb3BCIiwiTG9vcCIsInN0b3AiLCJyZWxlYXNlIiwicmFtcFRvIiwicGxheUluc3RydW1lbnRzIiwiUG9seVN5bnRoIiwiU3ludGgiLCJ0cmlnZ2VyQXR0YWNrIiwidHJpZ2dlclJlbGVhc2UiLCJwbGF5U2FtcGxlcyIsInBsYXllciIsIlBsYXllciIsImxvYWRlZCIsInRoZW4iLCJwbGF5U2FtcGxlciIsInNhbXBsZXIiLCJTYW1wbGVyIiwidXJscyIsIkM0IiwiQTQiLCJiYXNlVXJsIiwicGxheUVmZmVjdHRzIiwidXJsIiwiYXV0b3N0YXJ0IiwiZGlzdG9ydGlvbiIsIkRpc3RvcnRpb24iLCJwbGF5U2lnbmFsIiwib3NjIiwiT3NjaWxsYXRvciIsImZyZXF1ZW5jeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./frontend/playground/Sound.ts\n"));

/***/ })

});